{"meta":{"title":"WxhShine","subtitle":null,"description":null,"author":"XiaoHui","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"HTTP协议","slug":"HTTP协议","date":"2020-02-18T12:59:35.000Z","updated":"2020-02-18T16:50:57.210Z","comments":true,"path":"2020/02/18/HTTP协议/","link":"","permalink":"http://yoursite.com/2020/02/18/HTTP协议/","excerpt":"​ 超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是互联网的数据通信的基础。 ​ 从客户端到服务器端，从建立连接，然后发起请求，接着服务端响应， 最后断开连接，这是一次完整的HTTP请求。","text":"​ 超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是互联网的数据通信的基础。 ​ 从客户端到服务器端，从建立连接，然后发起请求，接着服务端响应， 最后断开连接，这是一次完整的HTTP请求。 一、建立连接​ 客户端向服务端发送请求之前，必须要建立两者之前的连接， 否则在不确定服务器的情况下发起请求，则会丢失。建立连接就是总所周知的三次握手： 首先客户端向服务端发送一个SYN序列通知服务端，它需要建立连接了； 然后如果服务端收到了，并正常做出回应，将回复客户端一个SYN和一个ACK，ACK的值是客户端的SYN+1； 最后客户端收到服务端的回应之后，需要向服务端发送一个ACK（值为服务端SYN+1），表示它收到了服务端的应答。 那么为什么是三次呢，首先如果是1次的话，客户端不能确认服务端是否收到连接请求；2次的话，服务端不能确认 客户端有没有收到回应；所以第3次服务端收到了回应，则通过第2次，第3次客户端和服务端都收到了回应，则可以建立连接；如果更多，则是没必要的。 二、发送请求​ 建立连接后，则开始发送HTTP请求，HTTP请求包含了：请求行，请求头，空行和请求数据 ​ 其中的请求方法有很多种，列几种常用的： GET：获取数据POST：传输数据，一般用来新增操作PUT：传输数据，一般用来修改或新增操作；有则修改，无则新增PATCH：传输数据，部分修改操作DELETE：删除数据​ 发送请求的路径是如下： 三、响应请求​ 发送完请求后由服务端响应，将处理请求后的数据返回给客户端， 响应体和请求体类似：状态行、响应头、空行和响应正文 其中状态码的含义有5种类型： 1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求四、断开连接​ 当客户端和服务端交互完毕后，为了不占用资源，则需要断开连接；断开连接服务端和客户端均可发起，采用四次挥手的方式确认断开 ​ 为什么四次是因为被动方在收到请求后会马上给一个回应，但是还需要确认自己是否还数据要传输，确认后才能发送FIN告诉主动方，我没有数据要发送。 以上就是整个HTTP请求。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"VirtualBox安装CentOS8","slug":"VirtualBox安装CentOS8","date":"2019-11-09T06:05:40.000Z","updated":"2019-11-09T10:11:30.894Z","comments":true,"path":"2019/11/09/VirtualBox安装CentOS8/","link":"","permalink":"http://yoursite.com/2019/11/09/VirtualBox安装CentOS8/","excerpt":"什么是Virtualbox？VirtualBox 是一款开源虚拟机软件(注：跟vmware差不多)。VirtualBox 是由德国 Innotek 公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在 Sun 被 Oracle 收购后正式更名成 Oracle VM VirtualBox。Innotek 以 GNU General Public License (GPL) 释出 VirtualBox，并提供二进制版本及 OSE 版本的代码。使用者可以在VirtualBox上安装并且执行Solaris、Windows、DOS、Linux、OS/2 Warp、BSD等系统作为客户端操作系统。 这里我使用Virtualbox虚拟机最新版本。","text":"什么是Virtualbox？VirtualBox 是一款开源虚拟机软件(注：跟vmware差不多)。VirtualBox 是由德国 Innotek 公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在 Sun 被 Oracle 收购后正式更名成 Oracle VM VirtualBox。Innotek 以 GNU General Public License (GPL) 释出 VirtualBox，并提供二进制版本及 OSE 版本的代码。使用者可以在VirtualBox上安装并且执行Solaris、Windows、DOS、Linux、OS/2 Warp、BSD等系统作为客户端操作系统。 这里我使用Virtualbox虚拟机最新版本。 什么是CentOS？CentOS（Community Enterprise Operating System，中文意思是：社区企业操作系统）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件。 下载安装工具 virtual box 官网 安装直接下一步即可 下载CentOS8 官网 开始安装CentOS8 以上步骤就安装成功. 设置CentOs8的网络 先查看此文件夹中的文件 1cd /etc/sysconfig/network-scripts 1ls 修改此文件”ifcfg-enp0s3” 1vim ifcfg-enp0s3 此文件夹的内容 1234567891011121314151617TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s3UUID=b87b55ce-d65f-46ff-a36b-62ac046af895DEVICE=enp0s3ONBOOT=noREFIX=22PEERROUTES=no 首先将 ONBOOT=no 改成 yes 将BOOTPROTO=dhcp改成static 添加IPADDR=(本机电脑的IP地址修改最后一位,例如: 192.168.2.**) 添加GATEWAY=(本机电脑的网关一致,例如:192.168.2.1) 添加NETMASK=(本机电脑的掩码一致, 例如:255.255.255.0) 添加DNS1=114.114.114.114 最后修改后的文件: 123456789101112131415161718192021TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticIPADDR=192.168.2.**GATEWAY=192.168.2.1NETMASK=255.255.255.0DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s3UUID=b87b55ce-d65f-46ff-a36b-62ac046af895DEVICE=enp0s3ONBOOT=yesREFIX=22DNS1=114.114.114.114PEERROUTES=no 然后重启网络 1systemctl restart NetworkManager 测试网络 1ping www.baidu.com 出现下图内容即可","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"},{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"读《用户故事与敏捷方法》","slug":"读《用户故事与敏捷方法》","date":"2019-10-05T13:56:11.000Z","updated":"2019-10-10T15:11:56.765Z","comments":true,"path":"2019/10/05/读《用户故事与敏捷方法》/","link":"","permalink":"http://yoursite.com/2019/10/05/读《用户故事与敏捷方法》/","excerpt":"当我第一次听到敏捷的时候，看名知意，敏捷即快速。听闻些许公司用敏捷开发，心里曾想，莫不是用什么高效率的开发方式来开发称为敏捷开发。 众所周知，IEEE830需求(瀑布式需求)。但是用户故事与IEEEE830需求的区别是什么呢？ IEEEE830需求声明关心解决方案的特征，用户故事关心用户目标。IEEEE830需求鼓励团队在写代码之前完成所有的需求声明，而不是像用户故事那样使用迭代的方式。写需求声明需要花费很大的精力来确保文字表达了正确的意思；用户故事鼓励通过口头的交流澄清细节。","text":"当我第一次听到敏捷的时候，看名知意，敏捷即快速。听闻些许公司用敏捷开发，心里曾想，莫不是用什么高效率的开发方式来开发称为敏捷开发。 众所周知，IEEE830需求(瀑布式需求)。但是用户故事与IEEEE830需求的区别是什么呢？ IEEEE830需求声明关心解决方案的特征，用户故事关心用户目标。IEEEE830需求鼓励团队在写代码之前完成所有的需求声明，而不是像用户故事那样使用迭代的方式。写需求声明需要花费很大的精力来确保文字表达了正确的意思；用户故事鼓励通过口头的交流澄清细节。 一.用户故事1.初始化用户故事必须要了解的一个就是用户故事卡。 由于用户故事的描述信息都是以传统的手写方式写在直至卡片上，所以Ron Jeffries对这三个方面起了一个非常好的以相同的英文字母开头的名字： 卡片（Card）：用户需求 对话（Conversion）：开发根据卡片同客户讨论用户需求的细节 确认（Confirm）：确认用户需求 2.卡片一个优秀的用户故事卡应该保证有以下几个特征： 独立的：每一个故事卡是一个很小的需求，卡与卡之间（需求与需求之间）没有关系连接，保证卡是独立的 可以讨论的：一个卡里面的内容可以与客户进行交流，才是一个好的卡，不能交流的卡完全丧失了敏捷故事卡存在的意义 对用户或者客户有价值的：记住对用户有价值的东西，才能避免多做很多没有价值的事 可以估计的：可以估计这张卡完成的时间 小的：史诗级别的卡（特别大的需求卡），就如同需求文档一般，这将会变得毫无意义，丧失了敏捷开发的特点 可以测试的：成功通过了测试表示开发人员实现了这个故事卡。 3.对话用户故事卡是作为对话的前提，避免了需求过于精确的假象，如果是需求文档，做的最好的无非就是完成了需求文档上面所有的精确的需求，然而，对话可以完成文档背后的需求。 4.确认测试，用于表达和编档故事细节并且可以确定用户故事什么时候能够完成。 5.意图故事卡的主要目的是用来提醒开发人员和客户团队对功能进行讨论的，既然是一个提醒，那么就要保持它的简介性。假如需要的细节，以便联想到继续对话的切入点，但不要在故事卡上面加入太多的细节并以此取代对话。 总结：编写用户故事卡就是在一个卡上正面写上最好一句话就可以描述完成的小需求，不要写太多的细节，细节自己和客户讨论（因为卡上面写上过多的细节会让人过于关注细节而忘记讨论才是正事）；卡的背面则可以写上这个故事卡所需要的测试。 二.用户角色建模1.初始化在很多项目中，需求分析人员只是从一个角度写用户故事，这样往往容易疏忽一些需求故事，因为故事针对的并不是系统的一般用户。 我们将通过用户角色，角色建模，角色映射和虚拟人物，模拟出更多的用户，编写更多不同角度细节的故事，来开发更好的软件。 2.为什么需要用户角色建模因为大部分项目小组只考虑到了单一的用户类型，这样会导致软件疏忽原本需要的一些用户的模型。 为了避免从单一用户的角度编写所有故事，要识别与软件交互的不同用户角色。通过每个用户角色定义的相关的特征，可以更加清楚地看到不同角色之间的不同点。 对于有些用户而言，用代表人物来描述会很有帮助。虚构人物是假想出来的用户角色代表。他们有名字，有照片，还有足够的相关的细节，因为对项目成员来说，很真实。 对于有些应用程序而言，极端人物可能有助于搜集原本被遗漏的故事。 总结：角色建模就是不光要考虑到最普通大众的需求，还要考虑到其他一些不同类型用户的需求。 三.搜集故事1.初始化如何和用户一起工作，如何通过与他们沟通来发现故事。为什么一定需要沟通：因为需求就像鱼一样，会成长，也可能会死亡。 2.用户访谈只需问用户“你们需要什么是不够的“，因为大部分用户不太善于理解，更难以表达他们的真实需求。 仅仅因为有些问题是由用户提出的就认为只有用户才有资格提出解决方案，这种观点是不对的。 3.搜索需求通过开放式的，与背景无关的提问更容易获得有用的答案，例如：”高速我你想怎么搜索工作“，就胜于”你要通过什么职位名称来搜索工作“。 我们可以通过用户访谈，观察用户，问卷调查和举办故事编写工作坊来发现有用的用户故事。 总结：面对用户故事卡，如何与客户交流来搜索到更有用的信息需求。 四.与客户代理合作1.初始化我们可能期望与不同的用户进行接触，这些用户代表来产品的不同角度，当我们无法接触到他们时，就代表我们需要求助于用户的代理（user proxy），他们自己可能不是用户，但他们在项目里面代表着用户。 2.可能的用户代理 用户的经理 开发经理 销售人员 市场营销团队 以前的用户 客户 领域专家 培训师和技术支持 业务分析师或者系统分析师 总结：因为不可能接触到所有的用户，只好委托一下用户代理来帮助我们更好地了解到用户的真实意图来写用户故事。 五.用户故事验收测试1.初始化验收测试提供了确认故事是否被完整实现的基本标准。 2.测试的两步流程 将测试要点记录在故事卡的背面，任何时候发现新的测试都可以记录在故事卡的背面。 将测试要点编程全面的侧首，这些测试可以用来演示故事已经正确，完整的实现了。 总结：验收测试就是写在用户故事卡背面的测试，在编写功能代码之前写下来的测试，当功能代码编写完毕，通过了之前写的测试，那么验收测试也算是完成了。 六.估算用户故事1.初始化估算这个故事卡，需要多长的时间才能够完成。 2.估算估算的目的是知道整个项目的工作量，所以最后我们总是要将估算换成时间。 3.故事点故事点没有特别准确的定义，完全根据团队而定。有的团队认为一个故事点为一个理想周的工作，有的团队则把一个故事点作为故事复杂度的测量。 4.正确地使用故事点 你的团队的故事点和我的团队的故事点事不一样的。你的团队估算的故事有三个故事点，而我的团队则估算的是5个故事点。 一个故事（可能是一个史诗故事）分解成一些小故事，这些小故事估算的总和不需要与开始那个史诗故事估算的故事点相同。 故事点好似故事复杂度，工作量或者工期的相对估算。 故事点应该由团队估算。 总结：估算故事点就是估计这个需求需要完成的时间。 七.发布计划1.初始化大部分软件以2-6个月为一个发布周期，这是最好的。 2.什么时候发布可迭代的，由故事驱动的过程使我们很容易确定一个日期，确定在指定日期里交付哪些哪些功能却比较困难。 3.优先级对于一个项目来说，应该先做最有风险的事，还是先做最有的价值的事？ 敏捷方法旗帜鲜明地支持先做最有价值的部分。 4.迭代长度短迭代允许项目更加频繁地作出调整，项目进度也更加透明；但是每一轮迭代会有少许额外开销。加入不确定迭代长度，请选择迭代短的而不是迭代长的，使用长迭代更加容易犯错。 5.初始速率执行一轮迭代以获取初始速率事一个很好的方法。但很多时候，这个方法并不可行。 所以可以考虑使用历史值或者猜测。 总结：分好了需求的优先级，估计好了初始速率，计算好了迭代的长度，大概确定好了发布日期，所做的这一系列的便是发布计划。一个发布计划中可能有多轮迭代。 八.迭代计划1.初始化利用发布计划，我们可以将粗粒的故事分配到发布中的多轮迭代。 在开始一轮迭代之前，再做更精细的进一步的计划也非常的重要。 2.迭代计划会议整个团队会举行一个迭代计划会议为下一轮的迭代做计划。 迭代计划会议的内容： 讨论故事 从故事中分解故事 开发人员成段每个任务的职责 讨论所有的故事，并且接受了所有的任务后，开发人员单独估计他们所承担的任务，以确保他们不会做出过于乐观的承诺。 总结：迭代会议就是分解任务，开发人员选择自己要做的任务。 总结用户故事与敏捷方法其实就是抛弃了瀑布式的需求文档，选择了轻巧的故事卡，通过建立与用户长时间的需求交流，模拟了不同类型的用户的想法，来完成相对精确需求的代码编写，验收测试的完成也代表了故事卡的完成。 通过迭代计划以及发布计划来规划了一次发布的几轮迭代，一轮的迭代会议是对下一轮迭代的进一步的计划：故事的拆分，故事的优先级，迭代的时间速率，开发人员对故事卡的自我选择。","categories":[{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://yoursite.com/categories/敏捷开发/"}],"tags":[{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://yoursite.com/tags/敏捷开发/"},{"name":"读后感","slug":"读后感","permalink":"http://yoursite.com/tags/读后感/"}]},{"title":"Kafka学习","slug":"Kafka学习","date":"2019-08-25T06:55:34.000Z","updated":"2019-08-25T09:29:27.609Z","comments":true,"path":"2019/08/25/Kafka学习/","link":"","permalink":"http://yoursite.com/2019/08/25/Kafka学习/","excerpt":"​ 消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不担心如何共享它。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用 - 一种是点对点，另一种是发布 - 订阅(pub-sub)消息系统。","text":"​ 消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不担心如何共享它。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用 - 一种是点对点，另一种是发布 - 订阅(pub-sub)消息系统。 Kafka概述关于kafka​ Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。 ​ Kafka是一个统一的平台，用于处理所有实时数据Feed。 Kafka支持低延迟消息传递，并在出现机器故障时提供对容错的保证。 它具有处理大量不同消费者的能力。 Kafka非常快，执行2百万写/秒。 Kafka将所有数据保存到磁盘，这实质上意味着所有写入都会进入操作系统(RAM)的页面缓存。 这使得将数据从页面缓存传输到网络套接字非常有效。 好处 可靠性：kafka是分布式，分区，复制的容错的。 可扩展性：kafka消息传递系统轻松缩放，无需停机。 耐用性：kafka使用“分布式提交日志”，消息会尽可能快地保留在磁盘上，因此它是持久的。 性能：kafka对于发布和订阅消息都是具有高吞吐量的的。即时存储了许多TB的消息，它也保持稳定的性能。 kafka非常快，并保证零停机和零数据丢失。 kafka术语 Topics(主题)：属于特定类别的消息流称为主题。数据存储在主题中。主题被拆分成分区。对于每个主题，kafka保存一个分区的数据。每个这样的分区包含不可变有序序列的消息。分区被实现为具有相等大小的一组分段文件。 Partition(分区)：主题可能有许多分区，因此它可以处理任意数量的数据，分区布置在不同的服务器上，负载均衡，打破性能瓶颈。 Partition offset(分区偏移)：每个分区消息具有称为“offset”的唯一序列标识。 Replicas of partition(分区备份)：副本只是一个分区的“备份”。副本从不读取或写入数据。他们用于防止数据丢失。 Brokers(经纪人)：（1）代理是负责维护发布数据的简单系统。每个代理中的每个主题可以具有0个或多个分区。假设，如果在一个主题和N个代理中有N个分区，每个代理将有一个分区。（2）假设在一个主题中有N个分区并且多于N个代理(n+m)，则每一个N代理将在具有一个分区，并且下一个M代理将不具有用于该特定主题的任何分区。（3）假设在一个主题中有N个分区并且小于N个代理（n-m），每个代理将在他们之间具有一个或多个分区共享。由于代理之间的负载分布不相等，不推荐使用此方案。 kafka cluster(kafka集群)：kafka有多个代理被称为kafka集群。可以扩展kafka集群，无需停机。这些集群用于管理消息数据的持久性和复制。 Producers(生产者)：生产者是发送给一个或多个kafka主题的消息的发布者。生产者向kafka经纪人发送数据。每当生产者将消息发布给代理时，代理只需将消息附加到最后一段文件。实际上，该消息将被附加到分区。生产者还可以向他们选择的分区发送消息。 Consumers(消费者)：消费者从经纪人处读取数据。消费者订阅一个或多个主题，并通过从代理中提取数据来使用已发布的消息。 Leader(领导者)：负责给定分区的所有读取和写入的节点。每个分区都有一个服务器充当Leader。 Follower(追随者)：跟随领导者指令的节点被称为Follower。如果领导失败，一个追随者将自动成为新的领导者。跟随者作为正常的消费者，拉取消息并更新自己的数据存储。","categories":[{"name":"kafka消息队列","slug":"kafka消息队列","permalink":"http://yoursite.com/categories/kafka消息队列/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://yoursite.com/tags/kafka/"},{"name":"消息队列","slug":"消息队列","permalink":"http://yoursite.com/tags/消息队列/"}]},{"title":"C#--垃圾回收","slug":"C-垃圾回收","date":"2019-08-11T01:35:47.000Z","updated":"2019-08-12T01:00:20.381Z","comments":true,"path":"2019/08/11/C-垃圾回收/","link":"","permalink":"http://yoursite.com/2019/08/11/C-垃圾回收/","excerpt":"​ 在C#中,内存的是由CLR进行管理，而在C\\C++中内存是由程序员手动管理。这样的弊端就很明显：1.忘记释放不需要的内存，造成内存泄露；2.尝试访问已释放的内存，造成内存破坏，程序错误，进而造成安全漏洞。而C#中由系统管理，不需要的内存，由CLR进行清理。清理不需要的内存，就是C#中的垃圾回收。","text":"​ 在C#中,内存的是由CLR进行管理，而在C\\C++中内存是由程序员手动管理。这样的弊端就很明显：1.忘记释放不需要的内存，造成内存泄露；2.尝试访问已释放的内存，造成内存破坏，程序错误，进而造成安全漏洞。而C#中由系统管理，不需要的内存，由CLR进行清理。清理不需要的内存，就是C#中的垃圾回收。 1.从托管堆分配资源​ 在CLR中,所有对象都是从托管堆中分配，在进程初始化时，CLR会为此进程划分一份地址空间区域作为托管堆，并且CLR中维护一个指针NextObjPtr（初始化时，为此空间区域的基地址），它指向下一个对象在托管堆中所要分配的地址。当此托管堆区域被非垃圾对象填满时，系统将分配更多地址空间。32位系统最多分配1.5GB，64位系统最多分配8TB。 ​ C#在初始化一个对象时有以下操作: 计算类型字段的所需字节数; 加上对象的开销所需字节数(类型对象指针,和同步块索引); CLR检查区域是否有足够的字节数分配给新对象; ​ 在托管堆中一般连续分配的对象都有较强的联系，所以连续的内存地址会引用“局部化”获得性能的提升，这样使进程工作集会非常小，应用程序只需要使用很少的内存，从而 提供速度。以上有个前提是内存无限，现实中，CLR通过“垃圾回收”，去清理不需要的对象，来尽可能增加内存使用效率。 2.垃圾回收算法​ 当程序调用new操作符时，没有足够的内存空间来分配是，CLR就执行垃圾回收。 引用计数垃圾回收器算法：（在Microsoft的“组件对象模型”用的就是此算法）这种算法，在程序中对上的每个对象都维护着一个内存字段来统计程序有多少“部分”正在使用对象。随着每一“部分”到达代码中某个不需要对象的地方，就递减对象的计数字段。计数字段变成0，对象就可以从内存中删除了。这有个弊端，在GUI应用程序中，窗口将容纳对子UI元素的引用，而子UI元素将容纳对父窗口的引用。这种引用会组织两个对象的计数器达到0，所以这两个对象永远不会删除。 这种算法因为存在问题，所以CLR使用另一种“引用跟踪算法”。 引用跟踪算法:此算法只关心引用类型的变量，只有这种变量才会引用堆上的对象，这种变量称为根。 (1)CLR开始执行GC时，首先暂停进程中的所有线程（防止线程在检查期间访问对象并更改状态）； (2)CLR进入GC的标记阶段，CLR遍历堆中的所有对象，将同步块索引字段中的一位设为0（0表示对象应删除）； (3)CLR检查所有活动根，检查他们引用了哪些对象（这就是引用跟踪）。如果根引用了堆上的对象，CLR就会标记被引用的对象，将该对象的同步块索引中的位设为1，一个对象被标记后，CLR会检查对象中的根，并标记他们引用的对象，如果发现对象已经被标记，则不重新检查对象的字段。（这就避免了引用计数垃圾回收器算法中的循环引用而产生的死循环，导致对象无法被删除）。 (4)检查完毕后，同步块索引中标记为0的被删除，标记为1的保留。 (5)执行GC中的压缩阶段，这个阶段将保留的对象所占的内存地址进行改变，使他们占用连续的内存地址（好处：1.使保留的对象恢复引用“局部化”，减小程序工作集，提升访问这些对象的性能；2.使剩下的可用空间也是连续的；3. 压缩空间，解决堆中的空间碎片化问题）。 3.代：提升性能​ CLR中的GC是基于代的垃圾回收器： 对象越新，生存周期越短; 对象越老，生存周期越长； 回收堆的一部分，速度快于回收整个堆。 其工作原理: 当程序首次运行时，新初始化的对象都为第0代对象； 当第0代对象占用的空间达到CLR中的预算容量时（CLR初始化时，会为每代的对象设置一个预存容量），GC开始执行，利用引用跟踪算法，将不可达的对象清理，而未清理的对象成为第1代对象。所以每次GC后，第0代就没有对象了； 然后新创建的对象则会分配到0代中，循环上面的清理过程。 当第1代对象占用的内存空间达到预设容量时，GC就是利用引用跟踪算法，清理第1代对象，而未清理的对象则会升为第2代对象（第2代对象为GC中的最高代对象，GC中只包含3代对象），在第1代对象没有达到预设容量时，则不会管第1代中的对象，就算在执行GC时，第1代中含有不可达对象，也不会在此时清理。 当然CLR中对每代对象的预设对象不是恒定不变的，比如：当每次回收第0代对象后，所存活的对象很少，则会减少第0代对象的内存空间预设容量；反之，每次回收第0代对象后，所存的对象很多，则会增加第0代对象的内存空间预设容量。 一个新初始化的堆,其中包含了一些对象, 这些对象都是0代, 有颜色的是可达对象, 无颜色的是不可达的. 经过一次垃圾回收, 第0代中的可达对象升级为第1代 ; 其他的被清除, 此时第0代没有对象 第0代分配了新对象,第1代有垃圾产生(第1代内存未达到预设值) 第2次回收后,第0代的可达对象升级为第1代, 之前第1代中的垃圾并没有被清理 第1代产生更多垃圾, 第0代有新增对象 第3次回收, 因为第1代已达到预设值, 则将第1代可达对象升级为第2代, 第0代可达对象升级为第1代.(垃圾回收中 最高为第2代) 4.垃圾回收触发条件 CLR在检测到第0代超过预算时; 代码显示调用system.GC的静态Collect方法; Windows报告低内存情况; CLR正在卸载AppDomain; CLR正在关闭.","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"GC","slug":"GC","permalink":"http://yoursite.com/tags/GC/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://yoursite.com/tags/垃圾回收/"}]},{"title":"异常处理-C#","slug":"异常处理-C","date":"2019-01-29T03:37:51.000Z","updated":"2019-08-25T03:14:48.322Z","comments":true,"path":"2019/01/29/异常处理-C/","link":"","permalink":"http://yoursite.com/2019/01/29/异常处理-C/","excerpt":"​ 异常处理是指程序在运行过程中，发生错误会导致程序退出，这种错误，就叫做异常。 因此处理这种错误，就称为异常处理。","text":"​ 异常处理是指程序在运行过程中，发生错误会导致程序退出，这种错误，就叫做异常。 因此处理这种错误，就称为异常处理。 异常处理机制​ 在C#中的异常处理机制是使用使用try, catch,finally代码块进行处理。 try块在try块中包含会抛出异常的代码；而且一个try快必须关联catch或者finally。 catch块在catch中包含处理异常的代码；一个try块可以关联多个catch块，catch后面的参数为捕捉类型，而他的捕捉类型必须是System.Exception或者它的派生类，如果有多个catch块，那么其中的捕捉类型必须是由子类由上至下的排列，一次捕捉；当然为了兼容其他CLR的语言(CLR允许抛出任何类型，不仅仅是Exception类及子类 ，比如Int32，DateTime，String)，所以catch后面也可以不许用加捕捉类型 1234567891011121314151617void Method()&#123; try&#123; .... &#125; catch(XxxException)&#123;//捕捉XxxException异常 ... &#125; catch(YyyException)&#123;//捕捉YyyException异常 ... &#125; catch(Excetion)&#123;//捕捉Exception异常 ... &#125; catch&#123;//捕捉所有抛出的试列 ... &#125;&#125; finally块 在finally块中包含必须执行的代码。一般finally块中执行try块中需要清理资源的操作，必须在打开了文件后，关闭文件就应放在finally块中： 1234567891011121314void Method(string pathName)&#123; FileStream fs = null; try&#123; fs = new FileStream(pathName,FileMode.Open); ... &#125; catch(IOException)&#123; ... &#125; finally&#123; //确保fs被清理 if(fs!=null) fs.Close(); &#125;&#125; 以上的代码就确保了是否try包含异常，文件都会被关闭。如果没有finally，那么文件关闭操作只会在垃圾回收中执行。 System.Exception类​ CLR允许抛出任何类型的实例。但是C#必须抛出System.Exception类及他的子类。 System.Exception类型常公共属性 属性名称 访问 类型 说明 Message 只读 String 错误消息以处理异常的开发人员为目标。Message属性的文本应该完整地描述错误，并且在可能的情况下，还应该解释如何更正错误。顶级异常处理程序可以向最终用户显示消息，因此您应该确保它在语法上是正确的，并且消息的每个句子都以句点结束。不要使用问号或感叹号。如果您的应用程序使用本地化的异常消息，则应确保准确转换它们 Data 只读 IDictionary 使用Data属性返回的System.Collections.IDictionary对象来存储和检索与异常相关的补充信息。代码在抛出异常前在该集合中添加记录项；捕捉异常的代码可在异常恢复过程中查询记录项并利用其中信息。 Source 读/写 String 包含生成异常的程序集名称。 StackTrace 只读 String 包含抛出异常前的堆栈信息。其中的信息是描述了异常发生前调用的哪些方法，这些信息用于检查代码，修复bug非常有效 InnerException 只读 Exception 如果当前异常是在处理一个异常时抛出的，指出上一个异常是什么 TargetSite 只读 MethodBase 包含抛出异常的方法。 一个异常抛出时，CLR会记录throw指令的位置,然后在访问StackTrace属性时将堆栈信息写入。 每次当throw ex时，会重置异常的起点。 12345678void Method()&#123; try&#123; .... &#125; catch(Exception ex)&#123; throw ex;//ex的StackTrace中的起点就更新为这里 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public static void MethodDemo1()&#123; string exstr1 = &quot;&quot;, exstr2=&quot;&quot;, exstr3=&quot;&quot;; try &#123; try &#123; try &#123; throw new Exception(&quot;这是一个异常&quot;); &#125; catch(Exception ex) &#123; exstr1 = ex.StackTrace; // at LearningDemo.ExceptionDemo.MethodDemo1() in C:\\Users\\wuxia\\Desktop\\桌面临时文件\\LearningDemo\\LearningDemo\\ExceptionDemo.cs:line 19 throw; &#125; &#125; catch(Exception ex) &#123; exstr2 = ex.StackTrace; // at LearningDemo.ExceptionDemo.MethodDemo1() in C:\\Users\\wuxia\\Desktop\\桌面临时文件\\LearningDemo\\LearningDemo\\ExceptionDemo.cs:line 19 throw ex; &#125; &#125; catch(Exception ex) &#123; exstr3 = ex.StackTrace; //at LearningDemo.ExceptionDemo.MethodDemo1() in C:\\Users\\wuxia\\Desktop\\桌面临时文件\\LearningDemo\\LearningDemo\\ExceptionDemo.cs:line 30 &#125; finally &#123; Console.WriteLine(exstr1); Console.WriteLine(exstr2); Console.WriteLine(exstr3); &#125;&#125; 在以上例子: exstr3中 是通过throw ex 抛出异常, 得到的ex.StackTrace则定位到throw ex的位置.","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"Exception","slug":"Exception","permalink":"http://yoursite.com/tags/Exception/"},{"name":"异常","slug":"异常","permalink":"http://yoursite.com/tags/异常/"}]},{"title":"泛型-Java与C#","slug":"泛型-Java与C","date":"2019-01-16T15:31:41.000Z","updated":"2019-02-10T09:18:41.832Z","comments":true,"path":"2019/01/16/泛型-Java与C/","link":"","permalink":"http://yoursite.com/2019/01/16/泛型-Java与C/","excerpt":"泛型是什么?​ 泛型:是可以在编程时，不确定使用某种类型时，用它来代替要使用的类，使之可以接受使用者指定的类，相当于类型参数化. ​ (百度百科上是这样定义的:1.在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。（这是当今较常见的定义）2.在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（人们大多把这称作模板）不论使用哪个定义，泛型的参数在真正使用泛型时都必须作出指明。)","text":"泛型是什么?​ 泛型:是可以在编程时，不确定使用某种类型时，用它来代替要使用的类，使之可以接受使用者指定的类，相当于类型参数化. ​ (百度百科上是这样定义的:1.在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。（这是当今较常见的定义）2.在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（人们大多把这称作模板）不论使用哪个定义，泛型的参数在真正使用泛型时都必须作出指明。) 泛型怎么用?​ 泛型的用法：1. 泛型方法；2. 泛型类； 泛型方法泛型方法可以使方法根据用户的使用让类型参数化, 可以在接受不同的类型; java:12345678910public class HelloWorld &#123; public static void main(String[] args) &#123; Print(\"Hello World\"); Print(123); &#125; public static &lt;T&gt; void Print (T printValue)&#123; System.out.println(printValue); &#125;&#125; c1234567891011static void Main(string[] args) &#123; Print(&quot;Hello world&quot;); Print(123); Console.Read();&#125;public static void Print&lt;T&gt;(T printValue)&#123; Console.WriteLine(printValue);&#125; 两个例子的打印结果都是一样的: 12Hello World123 ​ C#中的泛型方法中的泛型参数(T) 是写在方法名称后面 ​ Java中的泛型方法中的泛型参数(T)是写在返回类型的前面 ​ 如果要使用多个泛型参数则是在&lt;&gt;中两个参数间用 “,”隔开 比如&lt;T,K&gt; 泛型类(泛型接口)泛型类中的泛型的使用区间是在整个类中, 而泛型方法是在整个方法中使用. 并且子类继承这个泛型类,子类也可以使用此泛型(泛型接口同理) c 123456789101112131415161718 public class GenericDemo&lt;T&gt; &#123; public T PrintValue &#123; get; set; &#125; public void Print() &#123; Console.WriteLine(PrintValue); &#125; &#125; public class GenericDemoChild&lt;T&gt; : GenericDemo&lt;T&gt; &#123; public void PrintChild() &#123; Console.WriteLine(&quot;Chlid&quot; + PrintValue.ToString()); &#125; &#125; Java 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; var generic = new GenericDemo&lt;String&gt;(); generic.PrintValue = \"Hello World\"; generic.Print(); var genericChild = new GenericDemoChild&lt;Integer&gt;(); genericChild.PrintValue = 123; genericChild.ChildPrint(); &#125;&#125; public class GenericDemo&lt;T&gt; &#123; public T PrintValue; public void Print( )&#123; System.out.println(PrintValue); &#125;&#125;public class GenericDemoChild&lt;T&gt; extends GenericDemo&lt;T&gt; &#123; public void ChildPrint()&#123; System.out.println(PrintValue); &#125;&#125; C#与Java泛型的的不同之处c#: ​ c#中有泛型约束,限制泛型的条件;比如限制泛型的父类必须时某某类型,现在泛型必须有构造函数,必须实现的接口; 1public class Generic&lt;T&gt; where T : class , new()&#123;&#125; where T 后面加上针对 泛型T 约束的条件 class :约束T必须时引用类型; struct : 约束T必须时值类型; new() : 必须有无参构造函数(若是有其他约束条件 new()必须放在最后一个约束条件); 一个具体类名: 必须继承自此类; 一个接口名: 必须实现此接口. java: ​ 通配符 ? 表示泛型中可以任意的类型 1234567891011121314 public static void main(String[] args) &#123; List&lt;String&gt; stringlist = new ArrayList&lt;&gt;(); stringlist.add(\"hel\"); stringlist.add(\"11\"); Print(stringlist);List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); intList.add(11); intList.add(22); Print(intList); &#125; public static void Print(List&lt;?&gt; list)&#123; System.out.println(list); &#125; 上面的例子可以正确输出. 在通配符?后面加上 super(下) class类名 或者 extends(上) class类名 表示通配符的上下限","categories":[{"name":"C#与Java","slug":"C-与Java","permalink":"http://yoursite.com/categories/C-与Java/"}],"tags":[{"name":"Java C#","slug":"Java-C","permalink":"http://yoursite.com/tags/Java-C/"}]},{"title":"C#中关于对象的Clone","slug":"C-中关于对象的Clone","date":"2019-01-01T12:39:15.000Z","updated":"2019-01-06T14:46:43.637Z","comments":true,"path":"2019/01/01/C-中关于对象的Clone/","link":"","permalink":"http://yoursite.com/2019/01/01/C-中关于对象的Clone/","excerpt":"关于Clone一般区分为两种，浅拷贝和深拷贝。","text":"关于Clone一般区分为两种，浅拷贝和深拷贝。 浅拷贝​ 指的是拷贝一个对象的时候，只拷贝对对象的引用。当你修改一个对象的值后，另一个对象的值也会改变。在内存中引用类型的创建是创建在内存堆中，而内存栈中这是创建一个对内存堆中的地址的引用。值类型则是直接在内存栈中创建。 .net中实现浅拷贝的内置方法(System.Object的方法) MemberwiseClone()。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 将要进行浅度复制的对象,注意为引用类型 public class RefLine : ICloneable &#123; public RefPoint rPoint; public ValPoint vPoint; public RefLine(RefPoint rPoint, ValPoint vPoint) &#123; this.rPoint = rPoint; this.vPoint = vPoint; &#125; public object Clone() &#123; return this.MemberwiseClone();//.net中实现浅拷贝的内置方法(System.Object的方法) &#125; &#125; // 定义一个引用类型成员 public class RefPoint &#123; public int x; public RefPoint(int x) &#123; this.x = x; &#125; &#125; // 定义一个值类型成员 public struct ValPoint &#123; public int x; public ValPoint(int x) &#123; this.x = x; &#125; &#125; /// &lt;summary&gt; /// clone() 方法验证 /// &lt;/summary&gt; public static void demo2() &#123; RefPoint rPoint = new RefPoint(1); ValPoint vPoint = new ValPoint(1); RefLine line = new RefLine(rPoint, vPoint); RefLine newLine = (RefLine)line.Clone(); Console.WriteLine(&quot;Original： line.rPoint.x = &#123;0&#125;, line.vPoint.x= &#123;1&#125; &quot;, line.rPoint.x, line.vPoint.x); Console.WriteLine(&quot;Cloned： newLine.rPoint.x = &#123;0&#125;, newLine.vPoint.x = &#123;1&#125; &quot;, newLine.rPoint.x, newLine.vPoint.x); line.rPoint.x = 10; // 修改原先的line的引用类型成员 rPoint line.vPoint.x = 10; // 修改原先的line的值类型成员 vPoint Console.WriteLine(&quot;Original： line.rPoint.x = &#123;0&#125;, line.vPoint.x= &#123;1&#125; &quot;, line.rPoint.x, line.vPoint.x); Console.WriteLine(&quot;Cloned： newLine.rPoint.x = &#123;0&#125;, newLine.vPoint.x = &#123;1&#125; &quot;, newLine.rPoint.x, newLine.vPoint.x); &#125; static void Main(string[] args) &#123; demo2(); Console.Read(); &#125; 结果如下: 深拷贝:​ 指在内存堆中又创建一个和你Clone对象一样的对象。当你修改了旧对象中的某个值时，新对象也不会变。 ​ 深拷贝有多种实现方式: 1.深拷贝可以利用序列化反序列化对对象进行深度复制。 1234567891011121314/// &lt;summary&gt;/// 深拷贝/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public object Clone()&#123; using(var ms = new MemoryStream()) &#123; var bf = new BinaryFormatter(); bf.Serialize(ms, this); ms.Seek(0, SeekOrigin.Begin); return (bf.Deserialize(ms)); &#125;&#125; 注:使用序列化时记得在类上加上[serializable]的特性 2.利用反射的方式进行深度复制。 1234567891011121314public static T DeepCopyByReflect&lt;T&gt;(T obj)&#123; //如果是字符串或值类型则直接返回 if (obj is string || obj.GetType().IsValueType) return obj; object retval = Activator.CreateInstance(obj.GetType());//若obj没有无参构造函数,此语句报错 FieldInfo[] fields = obj.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static); foreach (FieldInfo field in fields) &#123; try &#123; field.SetValue(retval, DeepCopyByReflect(field.GetValue(obj))); &#125;//递归下去直到field为值类型或string给其赋值 catch &#123; &#125; &#125; return (T)retval;&#125; 注：使用反射时必须引用类型必须有无参构造函数 两种方式的结果相同，如下:","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"Clone","slug":"Clone","permalink":"http://yoursite.com/tags/Clone/"}]},{"title":"NoSql简介","slug":"NoSql简介","date":"2018-10-13T10:59:42.000Z","updated":"2018-11-03T16:00:40.454Z","comments":true,"path":"2018/10/13/NoSql简介/","link":"","permalink":"http://yoursite.com/2018/10/13/NoSql简介/","excerpt":"","text":"NoSql介绍Nosql全称Not Only Sql(不仅仅是Sql)也叫非关系型数据库, 通关系型数据库一样(SQL server, MySQL), 这种数据库一般也是用来保存数据的, 不够这种保存数据的优势在于性能更高, 速度更快,可以很好的处理大量的数据库引用, 满足解决大量的数据操作. NoSql数据库的四大分类键值(Key-Value)存储数据库​ 这种数据库主要使用哈希表, 哈希表中有一个唯一键和一个指针指向所保存的数据. Key-Value的优势就是在于简单, 易操作,易部署. 但是如果只对部分值进行查询或更新的时候, Key-Value就会相对效率较低.。典型的应用场景：内容缓存，主要用于处理大量数据的高访问负载，也用于日志系统。 ​ 优点： 查找速度快 ​ 缺点： 数据五结构化，通常自卑当作字符串或者二进制数据 ​ 此类型的应用包括: Redis, Memcache, Oracle BDB。 列存储数据库​ 这类数据库通常是用在应对分布式存储的海量数据. 它是一个键,指向多个列.。此类型主要用于分布式的文件系统。 ​ 优点： 查找速度快，可扩展性强，跟容易进行分布式扩展。 ​ 缺点： 功能相对局限。 ​ 此类型包括: Cassandra, HBase 文档型数据库​ 文档型数据库的灵感是来自于一款办公软件, 而且它同第一种键值存储相类似。该类型的数据库模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。 ​ 优点： 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 ​ 缺点： 查询性能不高，而且缺乏统一的查询语法（类似关系型数据库有统一的Sql语法） ​ 此类型包括：MongoDb，Sequoia DB，CouchDB 图形数据库​ 图形结构的数据库通其他行列以及刚性结构的Sql数据库不同，它是使用灵活的图形模型，并且能够拓展到多个服务器上。NoSql数据库没有标志的查询语言（sql），因此进行数据库查询需要制定数据库模型。许多Nosql数据库都有REST式的数据接口或者查询API。 ​ 优点： 利用图结构相关算法。比如最短路径寻址，N度关系查找。 ​ 缺点： 很多时候需要对整个图像计算才能得出需要的信息，而且这种结构不好做分布式 ​ 此类型包括：Neo4J， Infinite Graph， InfoGrid 所以NoSql数据库在一下几种情况下比较适用： 1. 数据模型比较简单； 2. 需要灵活性更强的IT系统； 3. 对数据库性能要求较高； 4. 不需要高度的数据库一致性； 5. 对于给定Key，比较容易映射复杂值的环境。 NoSql和关系型数据库的区别1.存储方式​ 关系型数据库是表格式，因此存储在表的行和列中。他们之前很容易关联写作存储，提取数据很方便。 ​ NoSql数据库则相反，他是整个组合在一起。通常存储在数据集中，就像文档，键值对或图结构。 2.存储结构​ 关系型数据库对应的是结构化数据，数据表都是预先定义了结构，结构描述了数据的形式和内容。则一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难。 ​ Nosql基于动态结构，使用与非结构化数据。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构变化。 3.存储规范​ 关系型数据库的数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。虽然管理起来很清晰，但是单个操作设计到多张表的时候，数据管理就显得麻烦。 ​ Nosql存储在数据集中，数据经常可能会重复。单个数据库很少被分割开，而是存储成了一个整体，这样整块数据更加便于读写。 4.存储扩展​ 两者的最大区别就在此。关系数据库是纵向扩展，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能设计到多个表，需要通过提升计算机性能克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限。 ​ Nosql是横向扩展，它的存储天然就是分布式的，可能通过给资源池添加更多的普通数据库服务器来分担负载。 5.查询方式​ 关系数据库通过结构化查询语言来操作数据库（sql）。sql支持数据库的CURD操作功能非常强大，是各大关系数据库的标准。 ​ Nosql查询是以单元操作数据，使用非结构化查询语言，它是没有标准的。 ​ 关系型数据库表中主键的概念对应Nosql中存储文档的ID。关系数据库使用预定义的优化方式（如索引）来加快查询操作，而Nosql更简单更精确的数据访问模式。 6.事务​ 关系数据库遵循ACID规则（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability））， ​ Nosql遵循BASE原则（基本可用（Basically Available）、软/柔性事务（Soft-State）、最终一致性（Eventual Consistency））。 ​ 由于关系数据库数据一致性强，所以对事务支持很好，易于回滚事务。而Nosql基于节点的分布式系统中，很难全部满足一致性，可用性，分区容忍度，所以对事务的指出不是很好。 7.性能​ 关系型数据库为了维护数据的一致性付出很大代价，读写性能差。在面对高并发时，读写性能非常差，面对海量的数据的时候，效率非常低。 ​ Nosql存储格式一般是Key-Value类型，并且存储在内存中，非常已于存储，而且对于数据的一致性是弱要求。Nosql无需sql解析，提高读写性能。 8.使用成本​ 关系数据库广泛使用的是SQL server，Oracle，Mysql。主流的Nosql数据库有redis，memcache，Mongodb。而大多关系数据库是需要付费使用，Nosql通常都是开源的。","categories":[{"name":"Nosql","slug":"Nosql","permalink":"http://yoursite.com/categories/Nosql/"}],"tags":[{"name":"Nosql","slug":"Nosql","permalink":"http://yoursite.com/tags/Nosql/"}]},{"title":"EF-CodeFirst:建表时单复数形式","slug":"EF-CodeFirst-建表时单复数形式","date":"2018-10-05T06:28:34.000Z","updated":"2019-08-11T01:53:38.000Z","comments":true,"path":"2018/10/05/EF-CodeFirst-建表时单复数形式/","link":"","permalink":"http://yoursite.com/2018/10/05/EF-CodeFirst-建表时单复数形式/","excerpt":"","text":"​ 默认情况下,CodeFirst模式建立表格的名称是复数形式,比如User类建立表格后的名称是”Users”. 有时我们并不想使对应表的名称是复数形式, 那么如此我们应该怎么设置? ​ 想控制数据库见表的规则, 那么就重写DbContext类中的OnModelCreating方法. 而其中的控制表格名称单复数也在其中 1234protected override void OnModelCreating(DbModelBuilder modelBuilder)&#123; modelBuilder.Conventions.Remove&lt;PluralizingTableNameConvention&gt;(); &#125; 其中PluralizingTableNameConvention此类必须得引用命名空间: System.Data.Entity.ModelConfiguration.Conventions; 重写生成后, 数据库表的名称就和Model类中的名称保持一致了.","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"EF","slug":"EF","permalink":"http://yoursite.com/tags/EF/"}]},{"title":"EF-CodeFirst模式","slug":"EF-CodeFirst模式","date":"2018-10-03T06:27:14.000Z","updated":"2019-08-11T01:53:19.854Z","comments":true,"path":"2018/10/03/EF-CodeFirst模式/","link":"","permalink":"http://yoursite.com/2018/10/03/EF-CodeFirst模式/","excerpt":"","text":"EF简介​ EF全称是Entity Framework,是微软官方提供的ORM(Object Relational Mapping 对象关系映射)工具，ORM让开发人员节省数据库访问的代码时间，将更多的时间放到业务逻辑层代码上。EF提供变更跟踪、唯一性约束、惰性加载、查询事物等。开发人员使用Linq语言，对数据库操作如同操作Object对象一样省事。 ​ EF由三种使用模式:1. Code First模式：由实体类生成数据库结构；2. Model First模式：通过数据库可视化设计器设计数据库，并生成实体类；3. Database First模式：由数据库生成实体类。 Code First模式 Code First模式我们称之为“代码优先”模式，是从EF4.1开始新建加入的功能。使用Code First模式进行EF开发时开发人员只需要编写对应的数据类（其实就是领域模型的实现过程），然后自动生成数据库。这样设计的好处在于我们可以针对概念模型进行所有数据操作而不必关系数据的存储关系，使我们可以更加自然的采用面向对象的方式进行面向数据的应用程序开发。 ​ Code First模式的使用： 在Vs2017中新建一个名为EFDemo的控制台应用程序项目如下新建一个user类，和一个UserContext类： User类： 1234567891011using System.ComponentModel.DataAnnotations;using System.ComponentModel.DataAnnotations.Schema;namespace EFDemo &#123; public class User &#123; [Key,Index]//设置Id为主键,并添加索引 public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Password &#123; get; set; &#125; &#125;&#125; UserContext类: 12345678using System.Data.Entity;namespace EFDemo &#123; public class UserContext :DbContext&#123; public UserContext() : base(&quot;EFDemoConnectionString&quot;) &#123; &#125; public DbSet&lt;User&gt; User &#123; get; set; &#125; &#125;&#125; 在建立UserContext中必须继承自 System.Data.Entity.DbContext类,才能有对数据的CRUD操作, 要使用DbContext类必须引用EntityFramework包.在NuGet中进行检索安装: 如下: 运行Main方法后,将自动生成数据库: 12345678910111213141516171819202122232425using System;using System.Linq;namespace EFDemo &#123; class Program &#123; static void Main(string[] args) &#123; using(var context = new UserContext()) &#123; var user = new User &#123; Id = 1, Name = &quot;user&quot;, Password = &quot;123&quot;, &#125;; context.User.Add(user);//新增一条数据 context.SaveChanges();//保存更改.每一次对数据库的CUD操作都应该使用此方法 var query = from a in context.User where a.Id == 1 select a;//Linq 语句用户快速查询 Console.Write($&quot;UserId:&#123;user.Id&#125;,UserName:&#123;user.Name &#125;,UserPassword:&#123;user.Password&#125;&quot;); Console.ReadKey(); &#125; &#125; &#125;&#125; 结果展示: 数据库展示:","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"EF","slug":"EF","permalink":"http://yoursite.com/tags/EF/"}]},{"title":"Log4Net--日志记录","slug":"Log4Net-日志记录","date":"2018-09-23T12:39:29.000Z","updated":"2018-11-12T14:06:39.256Z","comments":true,"path":"2018/09/23/Log4Net-日志记录/","link":"","permalink":"http://yoursite.com/2018/09/23/Log4Net-日志记录/","excerpt":"​ Log4Net是用来记录日志的，可以将程序运行过程中的信息输出到一些地方（文件、数据库、EventLog等），日志就是程序的黑匣子，可以通过日志查看系统的运行过程，从而发现系统的问题。日志的作用：将运行过程的步骤、成功失败记录下来，将关键性的数据记录下来分析系统问题所在。​ 对于网站来讲，不能把异常信息显示给用户，异常信息只能记录到日志，出了问题把日志文件发给开发人员，就能知道问题所在。","text":"​ Log4Net是用来记录日志的，可以将程序运行过程中的信息输出到一些地方（文件、数据库、EventLog等），日志就是程序的黑匣子，可以通过日志查看系统的运行过程，从而发现系统的问题。日志的作用：将运行过程的步骤、成功失败记录下来，将关键性的数据记录下来分析系统问题所在。​ 对于网站来讲，不能把异常信息显示给用户，异常信息只能记录到日志，出了问题把日志文件发给开发人员，就能知道问题所在。 ​ 第一步: 建立一个简单的日志记录程序; ​ 第二步: 添加对Log4net.dll的引用,可以通过NuGet导入,也可以通过官网http://logging.apache.org/log4net/下载; ​ 第三步: 将Log4Net的配置信息加入到程序中的配置文件.config中如下:(更多详细信息请查看官网.) 12345678910111213141516171819202122232425&lt;!--Log4Net配置--&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/&gt; &lt;/configSections&gt; &lt;log4net&gt; &lt;!-- Define some output appenders --&gt; &lt;appender name=\"RollingLogFileAppender\" type=\"log4net.Appender.RollingFileAppender\"&gt;&lt;!--type:表示将日志记录到滚动文件中,其中,AdoNetAppender(记录到数据库中),SmtpAppender(邮件),ConsoleAppender(控制台显示日志),EventLogAppender(Windows事件日志)--&gt; &lt;file value=\"test.txt\"/&gt;&lt;!--日志存放位置--&gt; &lt;appendToFile value=\"true\"/&gt;&lt;!--日志内容是否追加在文件中,false表示覆盖之前内容--&gt; &lt;maxSizeRollBackups value=\"10\"/&gt;&lt;!--当文件数据量超过存储量,则新建文件,属性表示最多备份多少文件--&gt; &lt;maximumFileSize value=\"1024KB\"/&gt;&lt;!--最大存储数据量--&gt; &lt;rollingStyle value=\"Size\"/&gt;&lt;!--滚动备份的方式,Size表示文件大小,Date表示日期--&gt; &lt;staticLogFileName value=\"true\"/&gt;&lt;!--日志文件名是否静态 --&gt; &lt;layout type=\"log4net.Layout.PatternLayout\"&gt; &lt;conversionPattern value=\"%date [%thread] %-5level %logger - %message%newline\"/&gt;&lt;!--表示输出格式:记录时间,线程Id,日志级别,出错类,错误描述,换行--&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;level value=\"ERROR\"/&gt;&lt;!--日志等级:None&gt;Fatal&gt;ERROR&gt;WARN&gt;DEBUG&gt;INFO&gt;ALL.如果日志级别低于此value级别,则不会记录--&gt; &lt;appender-ref ref=\"RollingLogFileAppender\"/&gt; &lt;/root&gt; &lt;!--可以设置多个Appender将日志信息分别记录到不同地方--&gt; &lt;/log4net&gt;&lt;/configuration&gt; ​ 第四步: 初始化Log4Net. 在程序最开始就初始化.log4net.Config.Xmlconfigtor.Configure();(读取配置文件中的配置信息); ​ 第五步: 在需要打印日志的地方 1234567891011 ILog log = log4net.LogManager.GetLogger(&quot;&quot;); //错误信息 log.Error(&quot;error&quot;,new Exception(&quot;错误异常信息&quot;));//崩溃信息 log.Fatal(&quot;fatal&quot;,new Exception(&quot;发生了一个致命错误&quot;));//记录一般信息 log.Info(&quot;info&quot;); //记录调试信息 log.Debug(&quot;debug&quot;); //记录警告信息 log.Warn(&quot;warn&quot;); 以上就是log4net基本应用方式","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"Log","slug":"Log","permalink":"http://yoursite.com/tags/Log/"}]},{"title":"Spring.Net--控制反转","slug":"Spring-Net-控制反转","date":"2018-09-15T12:38:46.000Z","updated":"2018-10-10T15:56:03.818Z","comments":true,"path":"2018/09/15/Spring-Net-控制反转/","link":"","permalink":"http://yoursite.com/2018/09/15/Spring-Net-控制反转/","excerpt":"","text":"​ Spring.Net 为建立企业级应用提供了一套轻量级的解决方案。通过Spring.NET，我们可以用统一且透明的方式来配置应用程序。Spring.NET的重点是为中间层提供声明式事务管理，以及一个功能齐全的ASP.NET扩展框架。Spring.NET是非侵入式的，代码对框架本身不会产生任何依赖. ​ Spring.Net 就是抽象工厂模式 , 它使用配置文件的方式,去是实现了控制反转, 控制反转就是通过依赖注入的方式是对象A不需要使用new对象B, 而是通过容器的方式,将对象B注入到对象A的应用. 通过简单的例子来介绍Spring.Net简单的使用: 第一步 : 先新建一个控制台程序; 第二步 : 引入Spring.Net文件,可用在NuGet中搜索,下载.也可以在官网中下载并在项目引用相关.dll文件; 第三步 : 接下来就是创建相关的类文件 123456789101112using System;namespace SpringdotNetDemo &#123; public class Service1 &#123; public string Name &#123; get; set; &#125; public Service2 Service &#123; get; set; &#125; public void Show() &#123; Service.Show(); Console.WriteLine(&quot;Spring.Net:&quot; + Name); &#125; &#125;&#125; 123456789using System;namespace SpringdotNetDemo &#123; public class Service2 &#123; public void Show() &#123; Console.WriteLine(&quot;Service2&quot;); &#125; &#125;&#125; 第四步 : 在App.Config中配置Spring.Net 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;!--Spring.Net节点配置--&gt; &lt;sectionGroup name=\"spring\"&gt; &lt;section name=\"context\" type=\"Spring.Context.Support.ContextHandler, Spring.Core\"/&gt; &lt;section name=\"objects\" type=\"Spring.Context.Support.DefaultSectionHandler, Spring.Core\" /&gt; &lt;/sectionGroup&gt; &lt;/configSections&gt; &lt;startup&gt; &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.6.1\" /&gt; &lt;/startup&gt; &lt;!--Spring.Net 配置--&gt; &lt;spring&gt; &lt;context&gt; &lt;!--容器配置--&gt; &lt;resource uri=\"config://spring/objects\"/&gt; &lt;!--可以将objects节点的配置保存在xml文件，更改文件更改属性，复制到输出目录：始终复制--&gt; &lt;!--&lt;resource uri=\"file://objects.xml\"/&gt;--&gt; &lt;/context&gt; &lt;objects xmlns=\"http://www.springframework.net\"&gt; &lt;!--这里放容器里面的所有节点--&gt; &lt;description&gt;An example that demonstrates simple IoC features.&lt;/description&gt; &lt;!--name 必须要唯一的，type=类的全名称，所在的程序集--&gt; &lt;object name=\"Service1\" type=\"SpringdotNetDemo.Serive1, SpringdotNetDemo\"&gt; &lt;!--设置Service1中属性的值--&gt; &lt;property name=\"Name\" value=\"Service1.Name\"/&gt; &lt;property name=\"Service\" ref=\"Service2\"/&gt; &lt;/object&gt; &lt;object name=\"Service2\" type=\"SpringdotNetDemo.Serive2, SpringdotNetDemo\"&gt;&lt;/object&gt; &lt;/objects&gt; &lt;/spring&gt;&lt;/configuration&gt; 第五步 : 在主函数中应用配置: 1234567891011121314151617using Spring.Context;using Spring.Context.Support;using System;namespace SpringdotNetDemo &#123; class Program &#123; static void Main(string[] args) &#123; //Spring.Net 创建实例的方式转为容器帮我们创建 //创建spring容器上下文 IApplicationContext context = ContextRegistry.GetContext(); //通过容器创建对象 var ser = context.GetObject(&quot;Service1&quot;) as Service1; ser.Show(); Console.ReadKey(); &#125; &#125;&#125; 其运行结果: 以上就是Spring.Net的简单应用","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Memcache--分布式缓存","slug":"Memcache-分布式缓存","date":"2018-09-02T12:40:59.000Z","updated":"2018-11-03T04:59:30.818Z","comments":true,"path":"2018/09/02/Memcache-分布式缓存/","link":"","permalink":"http://yoursite.com/2018/09/02/Memcache-分布式缓存/","excerpt":"","text":"MemCache简介​ MemCache 是一个分布式的高速缓存系统, 可以显著提高网站的访问速度,减少对数据库的访问. MemCache是一套开源代码.可以在GitHub上下载或者在官网上下载. ​ MemCache 的工作流程如下：先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）；每次更新数据库的同时更新memcached中的数据，保证一致性；当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据 ​ Memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。 ​ Memcache是danga的一个项目，最早是LiveJournal 服务的，最初为了加速 LiveJournal 访问速度而开发的，后来被很多大型的网站采用。 ​ Memcached是以守护程序(监听)方式运行于一个或多个服务器中，随时会接收客户端的连接和操作。 MemCache特性 在内存足够下的情况下Memcache中保存的item数据量是不受限制的;(Memcache单进程在32位系统下最大使用内存为2G,64位系统没有此限制); 最大30天的的数据过期时间, 由常量REALTIME_MAXDELTA 控制; 最大键长为250字节, 由常量KEY_MAX_LENGTH 控制; 单个Item最大的数据是1MB, 超过1MB的数据不存储, 由常量 POWER_BLOCK 控制 最大的连接数连接数是200; Memcached是一种无阻塞的socket通信方式服务，由于无阻塞通信，对内存读写速度非常之快; Memcached分服务器端和客户端，可以配置多个服务器端和客户端，应用于分布式的服务非常广泛; Memcached作为小规模的数据分布式平台是十分有效果的。 MemCache安装将Memcache的安装包解压在文件夹后，使用cmd命令进行安装： 12341. 开始&gt;运行：CMD；2. cd (Memcache解压后的文件夹)3. memcached -d install4. memcache -d start（启动memcache服务器，默认分配64M内存，使用11211端口） 目前Memcache服务器就可以正常使用 注意:必须使用管理员运行cmd","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"cache","slug":"cache","permalink":"http://yoursite.com/tags/cache/"}]},{"title":"C#中的匿名类型","slug":"Csharp中的匿名类型","date":"2018-08-15T08:14:16.000Z","updated":"2019-01-05T16:37:38.942Z","comments":true,"path":"2018/08/15/Csharp中的匿名类型/","link":"","permalink":"http://yoursite.com/2018/08/15/Csharp中的匿名类型/","excerpt":"​ 在一个项目中遇到了一个关于匿名类型的坑","text":"​ 在一个项目中遇到了一个关于匿名类型的坑 在C#中的匿名类型是这样创建的： 1new &#123;Id = 1, Name = &quot;Tom&quot;, Psw = &quot;123&quot;&#125;; 而这些匿名类型的属性是internal的，所以是只有在同一程序集才能使用。 ​ 在一个项目中我使用了dynamic去声明了一个参数，并且跨程序集调用了此方法，则会抛出异常： Microsoft.CSharp.RuntimeBinder.RuntimeBinderException ：object类中未包含Id的定义 12345678910111213141516171819202122232425//在一个项目添加此代码using System;namespace DynamicDemo &#123; class Program &#123; static void Main(string[] args) &#123; var user = new &#123; Id = 1, name = &quot;Tom&quot;, psw = &quot;123&quot; &#125;; LoginInter(user); Demo.Demo.Login(user); Console.ReadKey(); &#125; public static void LoginInter(dynamic user) &#123; Console.Write(user.Id + user.name + user.psw); &#125; &#125;&#125;//在另一个项目中添加此代码 生成的程序集是Demo.dllusing System;namespace Demo &#123; public class Demo &#123; public static void Login(dynamic user) &#123; Console.Write(user.Id + user.name + user.psw);//抛出异常 &#125; &#125;&#125; public 关键字是类型和类型成员的访问修饰符。公共访问是允许的最高访问级别，对访问公共成员没有限制。 protected 关键字是一个成员访问修饰符。受保护成员在它的类中可访问并且可由派生类访问。 private 关键字是一个成员访问修饰符。私有访问是允许的最低访问级别。私有成员只有在声明它们的类和结构体中才是可访问的。 internal 关键字是类型和类型成员的访问修饰符。只有在同一程序集的文件中，内部类型或成员才是可访问的。","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"多线程-Java与C#","slug":"多线程-Java与C#","date":"2018-07-22T06:44:47.000Z","updated":"2019-08-11T01:54:16.144Z","comments":true,"path":"2018/07/22/多线程-Java与C#/","link":"","permalink":"http://yoursite.com/2018/07/22/多线程-Java与C#/","excerpt":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看:","text":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看: 1.新建一个线程Java创建线程： 一种方法是：自定义一个类，继承Thread类，且重写其中的run()方法：例如： 1234567891011121314public class NewThread extends Thread&#123; //继承Tread类 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewThread thread = new NewThread(); thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; 另一种方法是：自定义个一类，继承Runable接口，并重写接口中的run()方法：例如; 123456789101112131415public class NewRunable implement Runable&#123; //继承Runable接口 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewRunable runable = new NewRunable(); Thread thread = new Thread(runable,) thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; C#创建线程：​ 通过创建一个Thread类接收一个ThreadStart委托或ParameterizedThreadStart委托，委托中包含新线程执行的的方法，例如： 123456789101112131415161718 class Program &#123; static void Main(string[] args) &#123; ThreadStart threadStart = new ThreadStart(Run); Thread thread = new Thread(threadStart); thread.Start(); for (int i = 0; i &lt; 100; i++) &#123; Console.WriteLine(&quot;this is main thread&quot; + i); &#125; Console.ReadKey(); &#125; //线程要 static void Run() &#123; for(int i = 0; i&lt;100; i++) &#123; Console.WriteLine(&quot;this is another thread&quot; + i); &#125; &#125; &#125;&#125; 2. 线程安全问题线程的生命周期：创建 ——-&gt;start()——-&gt;可运行状态（具备等待CPU的资格，不具备CPU的执行权）——-&gt;得到CPU的执行权——–&gt;运行状态(具备等待CPU和CPU的执行资格)(运行状态和可运行状态可相互装换)——–&gt;完成任务——–&gt;死亡状态 12sleep(ms) : 进入临时阻塞状态,那么线程一旦超过了指定了睡眠时间，那么就会重新进入可运行状态，wait：需要其他线程唤醒该线程才可以重新进入可运行状态。 引起线程安全问题的条件：1. 在多线程的环境下；2. 线程中有共享数据；3. 共享数据有多条语句操作，执行。 Java中线程安全问题的解决方案： 使用同步代码块， synchronize([锁对象]) (Note:锁对象可以是任何对象(object）,切是唯一共享的，否则无效。（最简单的定义一个锁可以使用 字符串） 我们使用一个比较典型的例子来实现此问题（售票窗口售票的问题） 12345678910111213141516171819202122232425262728293031323334class SaleWindow extends Thread&#123; public static int num = 50; //售票的剩余数 public SaleWindow(String name)&#123;super(name);&#125; @Override public void run()&#123; while(true)&#123; synchronized(&quot;lock&quot;)&#123; if(num &gt; 0)&#123; System.out.println(this.getName() + &quot;销售了第：&quot; + num + &quot;票&quot;); try&#123; Thread.sleep(100)； &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; num--; &#125; else&#123; System.out.println(&quot;售完&quot;); break; &#125; &#125; &#125; &#125;&#125;public class Sale &#123; public static void main (String[] args)&#123; SaleWindow win1 = new SaleWindow(&quot;窗口1：&quot;); SaleWindow win2 = new SaleWindow(&quot;窗口2：&quot;); SaleWindow win3 = new SaleWindow(&quot;窗口3：&quot;); win1.start(); win2.start(); win3.start(); &#125;&#125; 2.同步方法：使用 synchronize 修饰一个方法： public synchronize void run() NOTE: 如果是一个非静态的同步函数的锁对象是this对象，如果是静态的同步函数的锁对象是当前函数所属的字节码字节（class对象) 同步函数的锁对象是固定的，不能自定义； C#中线程安全的解决方案： lock关键字 类似于Java中的同步代码块，lock(“锁”){执行代码} 。不同的是lock中的参数只能是引用类型，因为如果使用基本类型所谓锁，这每次都会发生装箱操作，则每次lock中都会重新new一个对象。 NOTE: 尽量不要在public的类中使用lock，因为如此使用此类时，在不知情的情况下则会很容易造成死锁 尽量不要用public的字段作为锁，也会容易造成死锁； 不要用一个字符串作为锁，因为字符串被CLR“暂留”，就是说整个应用程序中给定的字符串都只有一个实例，因此更容易造成死锁现象。 1234567891011121314151617181920212223242526272829303132333435class Demo2 &#123; static int num = 50; static object lockThe = new object(); static void Run() &#123; while (true) &#123; lock (lockThe) &#123; if (num &gt; 0) &#123; Console.WriteLine(Thread.CurrentThread.Name + &quot;销售了第：&quot; + num + &quot;票&quot;); try &#123; Thread.Sleep(100); &#125; catch (Exception e) &#123; Console.WriteLine(e.StackTrace); &#125; num--; &#125; else &#123; Console.WriteLine(&quot;售完..&quot;); break; &#125; &#125; &#125; &#125; public static void Main(string[] args) &#123; ThreadStart start = new ThreadStart(Run); Thread win1 = new Thread(start); Thread win2 = new Thread(start); win1.Name = &quot;第一个窗口&quot;; win2.Name = &quot;第二个窗口&quot;; win1.Start(); win2.Start(); Console.ReadKey(); &#125;&#125; Monitor Monitor与lock类似，lock(object){} 等效于 Monitor.Enter(object)……Monitor.Exit(object). 1234567891011lock (object)&#123; Run();&#125;等效于：Monitor.Enter(object);try&#123; Run();&#125;finally&#123; Monitor.Exit(object);&#125; Mutex Mutex也是与Monitor类似,不过Mutex 有一个很大的特点，Mutex是跨进程的（博主不是很懂，会深入学习）。 Interlocked 如果只是对整形数据进行简单的操作，可以使用Interlocked来实现同步。此类的方法有：Increment（ref i)（对整数加一个），Decrement(ref i)（对整数减一个）,Exchange(ref i , 100)与将i变为100，CompareExchange(ref i, 10 , 100),比较两个值，如果i与100相同，则i将变成10，否则不变。","categories":[{"name":"C#与Java","slug":"C-与Java","permalink":"http://yoursite.com/categories/C-与Java/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"多线程-Java与C#","slug":"多线程-Java与C","date":"2018-07-22T06:44:47.000Z","updated":"2019-08-11T01:54:41.201Z","comments":true,"path":"2018/07/22/多线程-Java与C/","link":"","permalink":"http://yoursite.com/2018/07/22/多线程-Java与C/","excerpt":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看:","text":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看: 1.新建一个线程Java创建线程： 一种方法是：自定义一个类，继承Thread类，且重写其中的run()方法：例如： 1234567891011121314public class NewThread extends Thread&#123; //继承Tread类 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewThread thread = new NewThread(); thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; 另一种方法是：自定义个一类，继承Runable接口，并重写接口中的run()方法：例如; 123456789101112131415public class NewRunable implement Runable&#123; //继承Runable接口 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewRunable runable = new NewRunable(); Thread thread = new Thread(runable,) thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; C#创建线程： ​ 通过创建一个Thread类接收一个ThreadStart委托或ParameterizedThreadStart委托，委托中包含新线程执行的的方法，例如： 123456789101112131415161718 class Program &#123; static void Main(string[] args) &#123; ThreadStart threadStart = new ThreadStart(Run); Thread thread = new Thread(threadStart); thread.Start(); for (int i = 0; i &lt; 100; i++) &#123; Console.WriteLine(&quot;this is main thread&quot; + i); &#125; Console.ReadKey(); &#125; //线程要 static void Run() &#123; for(int i = 0; i&lt;100; i++) &#123; Console.WriteLine(&quot;this is another thread&quot; + i); &#125; &#125; &#125;&#125; 2. 线程安全问题线程的生命周期： 创建 ——-&gt;start()——-&gt;可运行状态（具备等待CPU的资格，不具备CPU的执行权）——-&gt;得到CPU的执行权——–&gt;运行状态(具备等待CPU和CPU的执行资格)(运行状态和可运行状态可相互装换)——–&gt;完成任务——–&gt;死亡状态 12sleep(ms) : 进入临时阻塞状态,那么线程一旦超过了指定了睡眠时间，那么就会重新进入可运行状态，wait：需要其他线程唤醒该线程才可以重新进入可运行状态。 1引起线程安全问题的条件：1. 在多线程的环境下；2. 线程中有共享数据；3. 共享数据有多条语句操作，执行。 Java中线程安全问题的解决方案： 使用同步代码块， synchronize([锁对象]) (Note:锁对象可以是任何对象(object）,切是唯一共享的，否则无效。（最简单的定义一个锁可以使用 字符串） 我们使用一个比较典型的例子来实现此问题（售票窗口售票的问题） 12345678910111213141516171819202122232425262728293031323334class SaleWindow extends Thread&#123; public static int num = 50; //售票的剩余数 public SaleWindow(String name)&#123;super(name);&#125; @Override public void run()&#123; while(true)&#123; synchronized(&quot;lock&quot;)&#123; if(num &gt; 0)&#123; System.out.println(this.getName() + &quot;销售了第：&quot; + num + &quot;票&quot;); try&#123; Thread.sleep(100)； &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; num--; &#125; else&#123; System.out.println(&quot;售完&quot;); break; &#125; &#125; &#125; &#125;&#125;public class Sale &#123; public static void main (String[] args)&#123; SaleWindow win1 = new SaleWindow(&quot;窗口1：&quot;); SaleWindow win2 = new SaleWindow(&quot;窗口2：&quot;); SaleWindow win3 = new SaleWindow(&quot;窗口3：&quot;); win1.start(); win2.start(); win3.start(); &#125;&#125; 2.同步方法：使用 synchronize 修饰一个方法： public synchronize void run() NOTE: 如果是一个非静态的同步函数的锁对象是this对象，如果是静态的同步函数的锁对象是当前函数所属的字节码字节（class对象) 同步函数的锁对象是固定的，不能自定义； C#中线程安全的解决方案： lock关键字 类似于Java中的同步代码块，lock(“锁”){执行代码} 。不同的是lock中的参数只能是引用类型，因为如果使用基本类型所谓锁，这每次都会发生装箱操作，则每次lock中都会重新new一个对象。 NOTE: 尽量不要在public的类中使用lock，因为如此使用此类时，在不知情的情况下则会很容易造成死锁 尽量不要用public的字段作为锁，也会容易造成死锁； 不要用一个字符串作为锁，因为字符串被CLR“暂留”，就是说整个应用程序中给定的字符串都只有一个实例，因此更容易造成死锁现象。 1234567891011121314151617181920212223242526272829303132333435class Demo2 &#123; static int num = 50; static object lockThe = new object(); static void Run() &#123; while (true) &#123; lock (lockThe) &#123; if (num &gt; 0) &#123; Console.WriteLine(Thread.CurrentThread.Name + &quot;销售了第：&quot; + num + &quot;票&quot;); try &#123; Thread.Sleep(100); &#125; catch (Exception e) &#123; Console.WriteLine(e.StackTrace); &#125; num--; &#125; else &#123; Console.WriteLine(&quot;售完..&quot;); break; &#125; &#125; &#125; &#125; public static void Main(string[] args) &#123; ThreadStart start = new ThreadStart(Run); Thread win1 = new Thread(start); Thread win2 = new Thread(start); win1.Name = &quot;第一个窗口&quot;; win2.Name = &quot;第二个窗口&quot;; win1.Start(); win2.Start(); Console.ReadKey(); &#125;&#125; Monitor Monitor与lock类似，lock(object){} 等效于 Monitor.Enter(object)……Monitor.Exit(object). 1234567891011lock (object)&#123; Run();&#125;等效于：Monitor.Enter(object);try&#123; Run();&#125;finally&#123; Monitor.Exit(object);&#125; Mutex Mutex也是与Monitor类似,不过Mutex 有一个很大的特点，Mutex是跨进程的（博主不是很懂，会深入学习）。 Interlocked 如果只是对整形数据进行简单的操作，可以使用Interlocked来实现同步。此类的方法有：Increment（ref i)（对整数加一个），Decrement(ref i)（对整数减一个）,Exchange(ref i , 100)与将i变为100，CompareExchange(ref i, 10 , 100),比较两个值，如果i与100相同，则i将变成10，否则不变。","categories":[{"name":"C#与Java","slug":"C-与Java","permalink":"http://yoursite.com/categories/C-与Java/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"MarkDown体验","slug":"MarkDown体验","date":"2018-07-20T12:38:46.000Z","updated":"2018-09-30T15:33:38.105Z","comments":true,"path":"2018/07/20/MarkDown体验/","link":"","permalink":"http://yoursite.com/2018/07/20/MarkDown体验/","excerpt":"&emsp;&emsp;使用MarkDown编写文章，首先要学会MarkDown的一些简单的语法，以下就是自己学习的一些简单的MD语法：","text":"&emsp;&emsp;使用MarkDown编写文章，首先要学会MarkDown的一些简单的语法，以下就是自己学习的一些简单的MD语法： 1.标题语法： &emsp;&emsp;在MD中有6个级别的标题： 一级标题用一个’#‘号表示，输入一个’#‘+一个空格就可以表示一级标题；二级标题则用两个’#‘表示（##），以此类推直到第六个标题，例如： # 一级标题 ## 二级标题 ### 三级标题 。。。 也可在末尾也加上’#‘号 # 一级标题 ## 二级标题 如此和上面的标题展现出来是一样的，只是看起来比较美观而已。（Note：MD的语法符号和字符之间需要格空格） &emsp;&emsp;另一种标题语法是，再标题的下面输入‘=’或‘-’号，这种方式只能有两种等级的标题，例如： 一级标题 ======== 二级标题 --------- 关于‘=’和‘-’的符号个数随自己而定 &emsp;&emsp;MD还兼容HTML标签，所以标题也可以用HTML标签去展示标签‘&lt;h1&gt;&lt;/h1&gt;’ 例如： &lt;h1&gt;title&lt;/h1&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;h3&gt;title&lt;/h3&gt; 2.缩进和换行&emsp;&emsp;缩进直接用占位符表示 【1】 &amp;ensp;或&amp;#8194; //半角 【2】 &amp;emsp;或&amp;#8195; //全角 【3】 &amp;nbsp;或&amp;#160; &emsp;&emsp;换行可以使用和HTML标签br标签,或者使用两个空格加上回车，或者两次回车。 3.列表&emsp;&emsp;无序列表使用‘*’或者‘+’或者‘-’ 后面加一个空格来标记，例如： * 列表1 + 列表2 - 列表3 * 列表1 + 列表2 - 列表3 * 列表1 + 列表2 - 列表3 &emsp;&emsp;有序列表使用数字加一个半角字符的‘.’,例如： 1. 列表 2. 列表 3. 列表 4.表格 header 1 header 2 row 1 col 1 row 1 col 2 row 2 col 1 row 2 col 2 符号的展示，例如: header 1 | header 2 ---|--- row 1 col 1 | row 1 col 2 row 2 col 1 | row 2 col 2 5.代码块 可以用1个制表符表示在空行点击“tab”键或者4个空格。 用“`”包含住代码块中的字符。 6.图片 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字 ![image](/path/path/image.jpg &quot;title&quot;) 7.超链接http://www.google.com/&#97;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#69;&#x6d;&#x61;&#x69;&#x6c;&#x40;&#101;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;符号展示如下： &lt;http://www.google.com/&gt; &lt;addressEmail@email.com&gt; 8.一些字体强调 加粗 **加粗** 斜体 ***斜体*** 以上的所有标记都可以用HTML表示","categories":[{"name":"MD语法","slug":"MD语法","permalink":"http://yoursite.com/categories/MD语法/"}],"tags":[{"name":"MD语法","slug":"MD语法","permalink":"http://yoursite.com/tags/MD语法/"}]}]}