{"meta":{"title":"WxhShine","subtitle":null,"description":null,"author":"XiaoHui","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"C#--垃圾回收","slug":"C-垃圾回收","date":"2019-08-11T01:35:47.000Z","updated":"2019-08-11T01:35:47.894Z","comments":true,"path":"2019/08/11/C-垃圾回收/","link":"","permalink":"http://yoursite.com/2019/08/11/C-垃圾回收/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HTTP协议","slug":"HTTP协议","date":"2019-02-08T12:59:35.000Z","updated":"2019-02-08T12:59:35.875Z","comments":true,"path":"2019/02/08/HTTP协议/","link":"","permalink":"http://yoursite.com/2019/02/08/HTTP协议/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"异常处理-JAVA与C#","slug":"异常处理-JAVA与C","date":"2019-01-19T09:17:29.000Z","updated":"2019-01-19T09:17:29.888Z","comments":true,"path":"2019/01/19/异常处理-JAVA与C/","link":"","permalink":"http://yoursite.com/2019/01/19/异常处理-JAVA与C/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"泛型-Java与C#","slug":"泛型-Java与C","date":"2019-01-16T15:31:41.000Z","updated":"2019-02-10T09:18:41.832Z","comments":true,"path":"2019/01/16/泛型-Java与C/","link":"","permalink":"http://yoursite.com/2019/01/16/泛型-Java与C/","excerpt":"泛型是什么?​ 泛型:是可以在编程时，不确定使用某种类型时，用它来代替要使用的类，使之可以接受使用者指定的类，相当于类型参数化. ​ (百度百科上是这样定义的:1.在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。（这是当今较常见的定义）2.在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（人们大多把这称作模板）不论使用哪个定义，泛型的参数在真正使用泛型时都必须作出指明。)","text":"泛型是什么?​ 泛型:是可以在编程时，不确定使用某种类型时，用它来代替要使用的类，使之可以接受使用者指定的类，相当于类型参数化. ​ (百度百科上是这样定义的:1.在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。（这是当今较常见的定义）2.在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（人们大多把这称作模板）不论使用哪个定义，泛型的参数在真正使用泛型时都必须作出指明。) 泛型怎么用?​ 泛型的用法：1. 泛型方法；2. 泛型类； 泛型方法泛型方法可以使方法根据用户的使用让类型参数化, 可以在接受不同的类型; java:12345678910public class HelloWorld &#123; public static void main(String[] args) &#123; Print(\"Hello World\"); Print(123); &#125; public static &lt;T&gt; void Print (T printValue)&#123; System.out.println(printValue); &#125;&#125; c1234567891011static void Main(string[] args) &#123; Print(&quot;Hello world&quot;); Print(123); Console.Read();&#125;public static void Print&lt;T&gt;(T printValue)&#123; Console.WriteLine(printValue);&#125; 两个例子的打印结果都是一样的: 12Hello World123 ​ C#中的泛型方法中的泛型参数(T) 是写在方法名称后面 ​ Java中的泛型方法中的泛型参数(T)是写在返回类型的前面 ​ 如果要使用多个泛型参数则是在&lt;&gt;中两个参数间用 “,”隔开 比如&lt;T,K&gt; 泛型类(泛型接口)泛型类中的泛型的使用区间是在整个类中, 而泛型方法是在整个方法中使用. 并且子类继承这个泛型类,子类也可以使用此泛型(泛型接口同理) c 123456789101112131415161718 public class GenericDemo&lt;T&gt; &#123; public T PrintValue &#123; get; set; &#125; public void Print() &#123; Console.WriteLine(PrintValue); &#125; &#125; public class GenericDemoChild&lt;T&gt; : GenericDemo&lt;T&gt; &#123; public void PrintChild() &#123; Console.WriteLine(&quot;Chlid&quot; + PrintValue.ToString()); &#125; &#125; Java 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; var generic = new GenericDemo&lt;String&gt;(); generic.PrintValue = \"Hello World\"; generic.Print(); var genericChild = new GenericDemoChild&lt;Integer&gt;(); genericChild.PrintValue = 123; genericChild.ChildPrint(); &#125;&#125; public class GenericDemo&lt;T&gt; &#123; public T PrintValue; public void Print( )&#123; System.out.println(PrintValue); &#125;&#125;public class GenericDemoChild&lt;T&gt; extends GenericDemo&lt;T&gt; &#123; public void ChildPrint()&#123; System.out.println(PrintValue); &#125;&#125; C#与Java泛型的的不同之处c#: ​ c#中有泛型约束,限制泛型的条件;比如限制泛型的父类必须时某某类型,现在泛型必须有构造函数,必须实现的接口; 1public class Generic&lt;T&gt; where T : class , new()&#123;&#125; where T 后面加上针对 泛型T 约束的条件 class :约束T必须时引用类型; struct : 约束T必须时值类型; new() : 必须有无参构造函数(若是有其他约束条件 new()必须放在最后一个约束条件); 一个具体类名: 必须继承自此类; 一个接口名: 必须实现此接口. java: ​ 通配符 ? 表示泛型中可以任意的类型 1234567891011121314 public static void main(String[] args) &#123; List&lt;String&gt; stringlist = new ArrayList&lt;&gt;(); stringlist.add(\"hel\"); stringlist.add(\"11\"); Print(stringlist);List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); intList.add(11); intList.add(22); Print(intList); &#125; public static void Print(List&lt;?&gt; list)&#123; System.out.println(list); &#125; 上面的例子可以正确输出. 在通配符?后面加上 super(下) class类名 或者 extends(上) class类名 表示通配符的上下限","categories":[{"name":"C#与Java","slug":"C-与Java","permalink":"http://yoursite.com/categories/C-与Java/"}],"tags":[{"name":"Java C#","slug":"Java-C","permalink":"http://yoursite.com/tags/Java-C/"}]},{"title":"C#中关于对象的Clone","slug":"C-中关于对象的Clone","date":"2019-01-01T12:39:15.000Z","updated":"2019-01-06T14:46:43.637Z","comments":true,"path":"2019/01/01/C-中关于对象的Clone/","link":"","permalink":"http://yoursite.com/2019/01/01/C-中关于对象的Clone/","excerpt":"关于Clone一般区分为两种，浅拷贝和深拷贝。","text":"关于Clone一般区分为两种，浅拷贝和深拷贝。 浅拷贝​ 指的是拷贝一个对象的时候，只拷贝对对象的引用。当你修改一个对象的值后，另一个对象的值也会改变。在内存中引用类型的创建是创建在内存堆中，而内存栈中这是创建一个对内存堆中的地址的引用。值类型则是直接在内存栈中创建。 .net中实现浅拷贝的内置方法(System.Object的方法) MemberwiseClone()。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 将要进行浅度复制的对象,注意为引用类型 public class RefLine : ICloneable &#123; public RefPoint rPoint; public ValPoint vPoint; public RefLine(RefPoint rPoint, ValPoint vPoint) &#123; this.rPoint = rPoint; this.vPoint = vPoint; &#125; public object Clone() &#123; return this.MemberwiseClone();//.net中实现浅拷贝的内置方法(System.Object的方法) &#125; &#125; // 定义一个引用类型成员 public class RefPoint &#123; public int x; public RefPoint(int x) &#123; this.x = x; &#125; &#125; // 定义一个值类型成员 public struct ValPoint &#123; public int x; public ValPoint(int x) &#123; this.x = x; &#125; &#125; /// &lt;summary&gt; /// clone() 方法验证 /// &lt;/summary&gt; public static void demo2() &#123; RefPoint rPoint = new RefPoint(1); ValPoint vPoint = new ValPoint(1); RefLine line = new RefLine(rPoint, vPoint); RefLine newLine = (RefLine)line.Clone(); Console.WriteLine(&quot;Original： line.rPoint.x = &#123;0&#125;, line.vPoint.x= &#123;1&#125; &quot;, line.rPoint.x, line.vPoint.x); Console.WriteLine(&quot;Cloned： newLine.rPoint.x = &#123;0&#125;, newLine.vPoint.x = &#123;1&#125; &quot;, newLine.rPoint.x, newLine.vPoint.x); line.rPoint.x = 10; // 修改原先的line的引用类型成员 rPoint line.vPoint.x = 10; // 修改原先的line的值类型成员 vPoint Console.WriteLine(&quot;Original： line.rPoint.x = &#123;0&#125;, line.vPoint.x= &#123;1&#125; &quot;, line.rPoint.x, line.vPoint.x); Console.WriteLine(&quot;Cloned： newLine.rPoint.x = &#123;0&#125;, newLine.vPoint.x = &#123;1&#125; &quot;, newLine.rPoint.x, newLine.vPoint.x); &#125; static void Main(string[] args) &#123; demo2(); Console.Read(); &#125; 结果如下: 深拷贝:​ 指在内存堆中又创建一个和你Clone对象一样的对象。当你修改了旧对象中的某个值时，新对象也不会变。 ​ 深拷贝有多种实现方式: 1.深拷贝可以利用序列化反序列化对对象进行深度复制。 1234567891011121314/// &lt;summary&gt;/// 深拷贝/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public object Clone()&#123; using(var ms = new MemoryStream()) &#123; var bf = new BinaryFormatter(); bf.Serialize(ms, this); ms.Seek(0, SeekOrigin.Begin); return (bf.Deserialize(ms)); &#125;&#125; 注:使用序列化时记得在类上加上[serializable]的特性 2.利用反射的方式进行深度复制。 1234567891011121314public static T DeepCopyByReflect&lt;T&gt;(T obj)&#123; //如果是字符串或值类型则直接返回 if (obj is string || obj.GetType().IsValueType) return obj; object retval = Activator.CreateInstance(obj.GetType());//若obj没有无参构造函数,此语句报错 FieldInfo[] fields = obj.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static); foreach (FieldInfo field in fields) &#123; try &#123; field.SetValue(retval, DeepCopyByReflect(field.GetValue(obj))); &#125;//递归下去直到field为值类型或string给其赋值 catch &#123; &#125; &#125; return (T)retval;&#125; 注：使用反射时必须引用类型必须有无参构造函数 两种方式的结果相同，如下:","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"Clone","slug":"Clone","permalink":"http://yoursite.com/tags/Clone/"}]},{"title":"NoSql简介","slug":"NoSql简介","date":"2018-10-13T10:59:42.000Z","updated":"2018-11-03T16:00:40.454Z","comments":true,"path":"2018/10/13/NoSql简介/","link":"","permalink":"http://yoursite.com/2018/10/13/NoSql简介/","excerpt":"","text":"NoSql介绍Nosql全称Not Only Sql(不仅仅是Sql)也叫非关系型数据库, 通关系型数据库一样(SQL server, MySQL), 这种数据库一般也是用来保存数据的, 不够这种保存数据的优势在于性能更高, 速度更快,可以很好的处理大量的数据库引用, 满足解决大量的数据操作. NoSql数据库的四大分类键值(Key-Value)存储数据库​ 这种数据库主要使用哈希表, 哈希表中有一个唯一键和一个指针指向所保存的数据. Key-Value的优势就是在于简单, 易操作,易部署. 但是如果只对部分值进行查询或更新的时候, Key-Value就会相对效率较低.。典型的应用场景：内容缓存，主要用于处理大量数据的高访问负载，也用于日志系统。 ​ 优点： 查找速度快 ​ 缺点： 数据五结构化，通常自卑当作字符串或者二进制数据 ​ 此类型的应用包括: Redis, Memcache, Oracle BDB。 列存储数据库​ 这类数据库通常是用在应对分布式存储的海量数据. 它是一个键,指向多个列.。此类型主要用于分布式的文件系统。 ​ 优点： 查找速度快，可扩展性强，跟容易进行分布式扩展。 ​ 缺点： 功能相对局限。 ​ 此类型包括: Cassandra, HBase 文档型数据库​ 文档型数据库的灵感是来自于一款办公软件, 而且它同第一种键值存储相类似。该类型的数据库模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。 ​ 优点： 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 ​ 缺点： 查询性能不高，而且缺乏统一的查询语法（类似关系型数据库有统一的Sql语法） ​ 此类型包括：MongoDb，Sequoia DB，CouchDB 图形数据库​ 图形结构的数据库通其他行列以及刚性结构的Sql数据库不同，它是使用灵活的图形模型，并且能够拓展到多个服务器上。NoSql数据库没有标志的查询语言（sql），因此进行数据库查询需要制定数据库模型。许多Nosql数据库都有REST式的数据接口或者查询API。 ​ 优点： 利用图结构相关算法。比如最短路径寻址，N度关系查找。 ​ 缺点： 很多时候需要对整个图像计算才能得出需要的信息，而且这种结构不好做分布式 ​ 此类型包括：Neo4J， Infinite Graph， InfoGrid 所以NoSql数据库在一下几种情况下比较适用： 1. 数据模型比较简单； 2. 需要灵活性更强的IT系统； 3. 对数据库性能要求较高； 4. 不需要高度的数据库一致性； 5. 对于给定Key，比较容易映射复杂值的环境。 NoSql和关系型数据库的区别1.存储方式​ 关系型数据库是表格式，因此存储在表的行和列中。他们之前很容易关联写作存储，提取数据很方便。 ​ NoSql数据库则相反，他是整个组合在一起。通常存储在数据集中，就像文档，键值对或图结构。 2.存储结构​ 关系型数据库对应的是结构化数据，数据表都是预先定义了结构，结构描述了数据的形式和内容。则一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难。 ​ Nosql基于动态结构，使用与非结构化数据。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构变化。 3.存储规范​ 关系型数据库的数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。虽然管理起来很清晰，但是单个操作设计到多张表的时候，数据管理就显得麻烦。 ​ Nosql存储在数据集中，数据经常可能会重复。单个数据库很少被分割开，而是存储成了一个整体，这样整块数据更加便于读写。 4.存储扩展​ 两者的最大区别就在此。关系数据库是纵向扩展，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能设计到多个表，需要通过提升计算机性能克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限。 ​ Nosql是横向扩展，它的存储天然就是分布式的，可能通过给资源池添加更多的普通数据库服务器来分担负载。 5.查询方式​ 关系数据库通过结构化查询语言来操作数据库（sql）。sql支持数据库的CURD操作功能非常强大，是各大关系数据库的标准。 ​ Nosql查询是以单元操作数据，使用非结构化查询语言，它是没有标准的。 ​ 关系型数据库表中主键的概念对应Nosql中存储文档的ID。关系数据库使用预定义的优化方式（如索引）来加快查询操作，而Nosql更简单更精确的数据访问模式。 6.事务​ 关系数据库遵循ACID规则（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability））， ​ Nosql遵循BASE原则（基本可用（Basically Available）、软/柔性事务（Soft-State）、最终一致性（Eventual Consistency））。 ​ 由于关系数据库数据一致性强，所以对事务支持很好，易于回滚事务。而Nosql基于节点的分布式系统中，很难全部满足一致性，可用性，分区容忍度，所以对事务的指出不是很好。 7.性能​ 关系型数据库为了维护数据的一致性付出很大代价，读写性能差。在面对高并发时，读写性能非常差，面对海量的数据的时候，效率非常低。 ​ Nosql存储格式一般是Key-Value类型，并且存储在内存中，非常已于存储，而且对于数据的一致性是弱要求。Nosql无需sql解析，提高读写性能。 8.使用成本​ 关系数据库广泛使用的是SQL server，Oracle，Mysql。主流的Nosql数据库有redis，memcache，Mongodb。而大多关系数据库是需要付费使用，Nosql通常都是开源的。","categories":[{"name":"Nosql","slug":"Nosql","permalink":"http://yoursite.com/categories/Nosql/"}],"tags":[{"name":"Nosql","slug":"Nosql","permalink":"http://yoursite.com/tags/Nosql/"}]},{"title":"EF-CodeFirst:建表时单复数形式","slug":"EF-CodeFirst-建表时单复数形式","date":"2018-10-05T06:28:34.000Z","updated":"2018-11-03T07:05:21.840Z","comments":true,"path":"2018/10/05/EF-CodeFirst-建表时单复数形式/","link":"","permalink":"http://yoursite.com/2018/10/05/EF-CodeFirst-建表时单复数形式/","excerpt":"","text":"​ 默认情况下,CodeFirst模式建立表格的名称是复数形式,比如User类建立表格后的名称是”Users”. 有时我们并不想使对应表的名称是复数形式, 那么如此我们应该怎么设置? ​ 想控制数据库见表的规则, 那么就重写DbContext类中的OnModelCreating方法. 而其中的控制表格名称单复数也在其中 1234protected override void OnModelCreating(DbModelBuilder modelBuilder)&#123; modelBuilder.Conventions.Remove&lt;PluralizingTableNameConvention&gt;(); &#125; 其中PluralizingTableNameConvention此类必须得引用命名空间: System.Data.Entity.ModelConfiguration.Conventions; 重写生成后, 数据库表的名称就和Model类中的名称保持一致了.","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C# , EF","slug":"C-EF","permalink":"http://yoursite.com/tags/C-EF/"}]},{"title":"EF-CodeFirst模式","slug":"EF-CodeFirst模式","date":"2018-10-03T06:27:14.000Z","updated":"2018-11-03T06:53:25.736Z","comments":true,"path":"2018/10/03/EF-CodeFirst模式/","link":"","permalink":"http://yoursite.com/2018/10/03/EF-CodeFirst模式/","excerpt":"","text":"EF简介​ EF全称是Entity Framework,是微软官方提供的ORM(Object Relational Mapping 对象关系映射)工具，ORM让开发人员节省数据库访问的代码时间，将更多的时间放到业务逻辑层代码上。EF提供变更跟踪、唯一性约束、惰性加载、查询事物等。开发人员使用Linq语言，对数据库操作如同操作Object对象一样省事。 ​ EF由三种使用模式:1. Code First模式：由实体类生成数据库结构；2. Model First模式：通过数据库可视化设计器设计数据库，并生成实体类；3. Database First模式：由数据库生成实体类。 Code First模式 Code First模式我们称之为“代码优先”模式，是从EF4.1开始新建加入的功能。使用Code First模式进行EF开发时开发人员只需要编写对应的数据类（其实就是领域模型的实现过程），然后自动生成数据库。这样设计的好处在于我们可以针对概念模型进行所有数据操作而不必关系数据的存储关系，使我们可以更加自然的采用面向对象的方式进行面向数据的应用程序开发。 ​ Code First模式的使用： 在Vs2017中新建一个名为EFDemo的控制台应用程序项目如下新建一个user类，和一个UserContext类： User类： 1234567891011using System.ComponentModel.DataAnnotations;using System.ComponentModel.DataAnnotations.Schema;namespace EFDemo &#123; public class User &#123; [Key,Index]//设置Id为主键,并添加索引 public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Password &#123; get; set; &#125; &#125;&#125; UserContext类: 12345678using System.Data.Entity;namespace EFDemo &#123; public class UserContext :DbContext&#123; public UserContext() : base(&quot;EFDemoConnectionString&quot;) &#123; &#125; public DbSet&lt;User&gt; User &#123; get; set; &#125; &#125;&#125; 在建立UserContext中必须继承自 System.Data.Entity.DbContext类,才能有对数据的CRUD操作, 要使用DbContext类必须引用EntityFramework包.在NuGet中进行检索安装: 如下: 运行Main方法后,将自动生成数据库: 12345678910111213141516171819202122232425using System;using System.Linq;namespace EFDemo &#123; class Program &#123; static void Main(string[] args) &#123; using(var context = new UserContext()) &#123; var user = new User &#123; Id = 1, Name = &quot;user&quot;, Password = &quot;123&quot;, &#125;; context.User.Add(user);//新增一条数据 context.SaveChanges();//保存更改.每一次对数据库的CUD操作都应该使用此方法 var query = from a in context.User where a.Id == 1 select a;//Linq 语句用户快速查询 Console.Write($&quot;UserId:&#123;user.Id&#125;,UserName:&#123;user.Name &#125;,UserPassword:&#123;user.Password&#125;&quot;); Console.ReadKey(); &#125; &#125; &#125;&#125; 结果展示: 数据库展示:","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C# , EF","slug":"C-EF","permalink":"http://yoursite.com/tags/C-EF/"}]},{"title":"Log4Net--日志记录","slug":"Log4Net-日志记录","date":"2018-09-23T12:39:29.000Z","updated":"2018-11-12T14:06:39.256Z","comments":true,"path":"2018/09/23/Log4Net-日志记录/","link":"","permalink":"http://yoursite.com/2018/09/23/Log4Net-日志记录/","excerpt":"​ Log4Net是用来记录日志的，可以将程序运行过程中的信息输出到一些地方（文件、数据库、EventLog等），日志就是程序的黑匣子，可以通过日志查看系统的运行过程，从而发现系统的问题。日志的作用：将运行过程的步骤、成功失败记录下来，将关键性的数据记录下来分析系统问题所在。​ 对于网站来讲，不能把异常信息显示给用户，异常信息只能记录到日志，出了问题把日志文件发给开发人员，就能知道问题所在。","text":"​ Log4Net是用来记录日志的，可以将程序运行过程中的信息输出到一些地方（文件、数据库、EventLog等），日志就是程序的黑匣子，可以通过日志查看系统的运行过程，从而发现系统的问题。日志的作用：将运行过程的步骤、成功失败记录下来，将关键性的数据记录下来分析系统问题所在。​ 对于网站来讲，不能把异常信息显示给用户，异常信息只能记录到日志，出了问题把日志文件发给开发人员，就能知道问题所在。 ​ 第一步: 建立一个简单的日志记录程序; ​ 第二步: 添加对Log4net.dll的引用,可以通过NuGet导入,也可以通过官网http://logging.apache.org/log4net/下载; ​ 第三步: 将Log4Net的配置信息加入到程序中的配置文件.config中如下:(更多详细信息请查看官网.) 12345678910111213141516171819202122232425&lt;!--Log4Net配置--&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/&gt; &lt;/configSections&gt; &lt;log4net&gt; &lt;!-- Define some output appenders --&gt; &lt;appender name=\"RollingLogFileAppender\" type=\"log4net.Appender.RollingFileAppender\"&gt;&lt;!--type:表示将日志记录到滚动文件中,其中,AdoNetAppender(记录到数据库中),SmtpAppender(邮件),ConsoleAppender(控制台显示日志),EventLogAppender(Windows事件日志)--&gt; &lt;file value=\"test.txt\"/&gt;&lt;!--日志存放位置--&gt; &lt;appendToFile value=\"true\"/&gt;&lt;!--日志内容是否追加在文件中,false表示覆盖之前内容--&gt; &lt;maxSizeRollBackups value=\"10\"/&gt;&lt;!--当文件数据量超过存储量,则新建文件,属性表示最多备份多少文件--&gt; &lt;maximumFileSize value=\"1024KB\"/&gt;&lt;!--最大存储数据量--&gt; &lt;rollingStyle value=\"Size\"/&gt;&lt;!--滚动备份的方式,Size表示文件大小,Date表示日期--&gt; &lt;staticLogFileName value=\"true\"/&gt;&lt;!--日志文件名是否静态 --&gt; &lt;layout type=\"log4net.Layout.PatternLayout\"&gt; &lt;conversionPattern value=\"%date [%thread] %-5level %logger - %message%newline\"/&gt;&lt;!--表示输出格式:记录时间,线程Id,日志级别,出错类,错误描述,换行--&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;level value=\"ERROR\"/&gt;&lt;!--日志等级:None&gt;Fatal&gt;ERROR&gt;WARN&gt;DEBUG&gt;INFO&gt;ALL.如果日志级别低于此value级别,则不会记录--&gt; &lt;appender-ref ref=\"RollingLogFileAppender\"/&gt; &lt;/root&gt; &lt;!--可以设置多个Appender将日志信息分别记录到不同地方--&gt; &lt;/log4net&gt;&lt;/configuration&gt; ​ 第四步: 初始化Log4Net. 在程序最开始就初始化.log4net.Config.Xmlconfigtor.Configure();(读取配置文件中的配置信息); ​ 第五步: 在需要打印日志的地方 1234567891011 ILog log = log4net.LogManager.GetLogger(&quot;&quot;); //错误信息 log.Error(&quot;error&quot;,new Exception(&quot;错误异常信息&quot;));//崩溃信息 log.Fatal(&quot;fatal&quot;,new Exception(&quot;发生了一个致命错误&quot;));//记录一般信息 log.Info(&quot;info&quot;); //记录调试信息 log.Debug(&quot;debug&quot;); //记录警告信息 log.Warn(&quot;warn&quot;); 以上就是log4net基本应用方式","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"Log","slug":"Log","permalink":"http://yoursite.com/tags/Log/"}]},{"title":"Spring.Net--控制反转","slug":"Spring-Net-控制反转","date":"2018-09-15T12:38:46.000Z","updated":"2018-10-10T15:56:03.818Z","comments":true,"path":"2018/09/15/Spring-Net-控制反转/","link":"","permalink":"http://yoursite.com/2018/09/15/Spring-Net-控制反转/","excerpt":"","text":"​ Spring.Net 为建立企业级应用提供了一套轻量级的解决方案。通过Spring.NET，我们可以用统一且透明的方式来配置应用程序。Spring.NET的重点是为中间层提供声明式事务管理，以及一个功能齐全的ASP.NET扩展框架。Spring.NET是非侵入式的，代码对框架本身不会产生任何依赖. ​ Spring.Net 就是抽象工厂模式 , 它使用配置文件的方式,去是实现了控制反转, 控制反转就是通过依赖注入的方式是对象A不需要使用new对象B, 而是通过容器的方式,将对象B注入到对象A的应用. 通过简单的例子来介绍Spring.Net简单的使用: 第一步 : 先新建一个控制台程序; 第二步 : 引入Spring.Net文件,可用在NuGet中搜索,下载.也可以在官网中下载并在项目引用相关.dll文件; 第三步 : 接下来就是创建相关的类文件 123456789101112using System;namespace SpringdotNetDemo &#123; public class Service1 &#123; public string Name &#123; get; set; &#125; public Service2 Service &#123; get; set; &#125; public void Show() &#123; Service.Show(); Console.WriteLine(&quot;Spring.Net:&quot; + Name); &#125; &#125;&#125; 123456789using System;namespace SpringdotNetDemo &#123; public class Service2 &#123; public void Show() &#123; Console.WriteLine(&quot;Service2&quot;); &#125; &#125;&#125; 第四步 : 在App.Config中配置Spring.Net 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;!--Spring.Net节点配置--&gt; &lt;sectionGroup name=\"spring\"&gt; &lt;section name=\"context\" type=\"Spring.Context.Support.ContextHandler, Spring.Core\"/&gt; &lt;section name=\"objects\" type=\"Spring.Context.Support.DefaultSectionHandler, Spring.Core\" /&gt; &lt;/sectionGroup&gt; &lt;/configSections&gt; &lt;startup&gt; &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.6.1\" /&gt; &lt;/startup&gt; &lt;!--Spring.Net 配置--&gt; &lt;spring&gt; &lt;context&gt; &lt;!--容器配置--&gt; &lt;resource uri=\"config://spring/objects\"/&gt; &lt;!--可以将objects节点的配置保存在xml文件，更改文件更改属性，复制到输出目录：始终复制--&gt; &lt;!--&lt;resource uri=\"file://objects.xml\"/&gt;--&gt; &lt;/context&gt; &lt;objects xmlns=\"http://www.springframework.net\"&gt; &lt;!--这里放容器里面的所有节点--&gt; &lt;description&gt;An example that demonstrates simple IoC features.&lt;/description&gt; &lt;!--name 必须要唯一的，type=类的全名称，所在的程序集--&gt; &lt;object name=\"Service1\" type=\"SpringdotNetDemo.Serive1, SpringdotNetDemo\"&gt; &lt;!--设置Service1中属性的值--&gt; &lt;property name=\"Name\" value=\"Service1.Name\"/&gt; &lt;property name=\"Service\" ref=\"Service2\"/&gt; &lt;/object&gt; &lt;object name=\"Service2\" type=\"SpringdotNetDemo.Serive2, SpringdotNetDemo\"&gt;&lt;/object&gt; &lt;/objects&gt; &lt;/spring&gt;&lt;/configuration&gt; 第五步 : 在主函数中应用配置: 1234567891011121314151617using Spring.Context;using Spring.Context.Support;using System;namespace SpringdotNetDemo &#123; class Program &#123; static void Main(string[] args) &#123; //Spring.Net 创建实例的方式转为容器帮我们创建 //创建spring容器上下文 IApplicationContext context = ContextRegistry.GetContext(); //通过容器创建对象 var ser = context.GetObject(&quot;Service1&quot;) as Service1; ser.Show(); Console.ReadKey(); &#125; &#125;&#125; 其运行结果: 以上就是Spring.Net的简单应用","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Memcache--分布式缓存","slug":"Memcache-分布式缓存","date":"2018-09-02T12:40:59.000Z","updated":"2018-11-03T04:59:30.818Z","comments":true,"path":"2018/09/02/Memcache-分布式缓存/","link":"","permalink":"http://yoursite.com/2018/09/02/Memcache-分布式缓存/","excerpt":"","text":"MemCache简介​ MemCache 是一个分布式的高速缓存系统, 可以显著提高网站的访问速度,减少对数据库的访问. MemCache是一套开源代码.可以在GitHub上下载或者在官网上下载. ​ MemCache 的工作流程如下：先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）；每次更新数据库的同时更新memcached中的数据，保证一致性；当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据 ​ Memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。 ​ Memcache是danga的一个项目，最早是LiveJournal 服务的，最初为了加速 LiveJournal 访问速度而开发的，后来被很多大型的网站采用。 ​ Memcached是以守护程序(监听)方式运行于一个或多个服务器中，随时会接收客户端的连接和操作。 MemCache特性 在内存足够下的情况下Memcache中保存的item数据量是不受限制的;(Memcache单进程在32位系统下最大使用内存为2G,64位系统没有此限制); 最大30天的的数据过期时间, 由常量REALTIME_MAXDELTA 控制; 最大键长为250字节, 由常量KEY_MAX_LENGTH 控制; 单个Item最大的数据是1MB, 超过1MB的数据不存储, 由常量 POWER_BLOCK 控制 最大的连接数连接数是200; Memcached是一种无阻塞的socket通信方式服务，由于无阻塞通信，对内存读写速度非常之快; Memcached分服务器端和客户端，可以配置多个服务器端和客户端，应用于分布式的服务非常广泛; Memcached作为小规模的数据分布式平台是十分有效果的。 MemCache安装将Memcache的安装包解压在文件夹后，使用cmd命令进行安装： 12341. 开始&gt;运行：CMD；2. cd (Memcache解压后的文件夹)3. memcached -d install4. memcache -d start（启动memcache服务器，默认分配64M内存，使用11211端口） 目前Memcache服务器就可以正常使用 注意:必须使用管理员运行cmd","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"cache","slug":"cache","permalink":"http://yoursite.com/tags/cache/"}]},{"title":"C#中的匿名类型","slug":"Csharp中的匿名类型","date":"2018-08-15T08:14:16.000Z","updated":"2019-01-05T16:37:38.942Z","comments":true,"path":"2018/08/15/Csharp中的匿名类型/","link":"","permalink":"http://yoursite.com/2018/08/15/Csharp中的匿名类型/","excerpt":"​ 在一个项目中遇到了一个关于匿名类型的坑","text":"​ 在一个项目中遇到了一个关于匿名类型的坑 在C#中的匿名类型是这样创建的： 1new &#123;Id = 1, Name = &quot;Tom&quot;, Psw = &quot;123&quot;&#125;; 而这些匿名类型的属性是internal的，所以是只有在同一程序集才能使用。 ​ 在一个项目中我使用了dynamic去声明了一个参数，并且跨程序集调用了此方法，则会抛出异常： Microsoft.CSharp.RuntimeBinder.RuntimeBinderException ：object类中未包含Id的定义 12345678910111213141516171819202122232425//在一个项目添加此代码using System;namespace DynamicDemo &#123; class Program &#123; static void Main(string[] args) &#123; var user = new &#123; Id = 1, name = &quot;Tom&quot;, psw = &quot;123&quot; &#125;; LoginInter(user); Demo.Demo.Login(user); Console.ReadKey(); &#125; public static void LoginInter(dynamic user) &#123; Console.Write(user.Id + user.name + user.psw); &#125; &#125;&#125;//在另一个项目中添加此代码 生成的程序集是Demo.dllusing System;namespace Demo &#123; public class Demo &#123; public static void Login(dynamic user) &#123; Console.Write(user.Id + user.name + user.psw);//抛出异常 &#125; &#125;&#125; public 关键字是类型和类型成员的访问修饰符。公共访问是允许的最高访问级别，对访问公共成员没有限制。 protected 关键字是一个成员访问修饰符。受保护成员在它的类中可访问并且可由派生类访问。 private 关键字是一个成员访问修饰符。私有访问是允许的最低访问级别。私有成员只有在声明它们的类和结构体中才是可访问的。 internal 关键字是类型和类型成员的访问修饰符。只有在同一程序集的文件中，内部类型或成员才是可访问的。","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"多线程-Java与C#","slug":"多线程-Java与C#","date":"2018-07-22T06:44:47.000Z","updated":"2019-01-16T15:38:59.996Z","comments":true,"path":"2018/07/22/多线程-Java与C#/","link":"","permalink":"http://yoursite.com/2018/07/22/多线程-Java与C#/","excerpt":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看:","text":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看: 1.新建一个线程Java创建线程： 一种方法是：自定义一个类，继承Thread类，且重写其中的run()方法：例如： 1234567891011121314public class NewThread extends Thread&#123; //继承Tread类 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewThread thread = new NewThread(); thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; 另一种方法是：自定义个一类，继承Runable接口，并重写接口中的run()方法：例如; 123456789101112131415public class NewRunable implement Runable&#123; //继承Runable接口 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewRunable runable = new NewRunable(); Thread thread = new Thread(runable,) thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; C#创建线程：​ 通过创建一个Thread类接收一个ThreadStart委托或ParameterizedThreadStart委托，委托中包含新线程执行的的方法，例如： 123456789101112131415161718 class Program &#123; static void Main(string[] args) &#123; ThreadStart threadStart = new ThreadStart(Run); Thread thread = new Thread(threadStart); thread.Start(); for (int i = 0; i &lt; 100; i++) &#123; Console.WriteLine(&quot;this is main thread&quot; + i); &#125; Console.ReadKey(); &#125; //线程要 static void Run() &#123; for(int i = 0; i&lt;100; i++) &#123; Console.WriteLine(&quot;this is another thread&quot; + i); &#125; &#125; &#125;&#125; 2. 线程安全问题线程的生命周期：创建 ——-&gt;start()——-&gt;可运行状态（具备等待CPU的资格，不具备CPU的执行权）——-&gt;得到CPU的执行权——–&gt;运行状态(具备等待CPU和CPU的执行资格)(运行状态和可运行状态可相互装换)——–&gt;完成任务——–&gt;死亡状态 12sleep(ms) : 进入临时阻塞状态,那么线程一旦超过了指定了睡眠时间，那么就会重新进入可运行状态，wait：需要其他线程唤醒该线程才可以重新进入可运行状态。 引起线程安全问题的条件：1. 在多线程的环境下；2. 线程中有共享数据；3. 共享数据有多条语句操作，执行。 Java中线程安全问题的解决方案： 使用同步代码块， synchronize([锁对象]) (Note:锁对象可以是任何对象(object）,切是唯一共享的，否则无效。（最简单的定义一个锁可以使用 字符串） 我们使用一个比较典型的例子来实现此问题（售票窗口售票的问题） 12345678910111213141516171819202122232425262728293031323334class SaleWindow extends Thread&#123; public static int num = 50; //售票的剩余数 public SaleWindow(String name)&#123;super(name);&#125; @Override public void run()&#123; while(true)&#123; synchronized(&quot;lock&quot;)&#123; if(num &gt; 0)&#123; System.out.println(this.getName() + &quot;销售了第：&quot; + num + &quot;票&quot;); try&#123; Thread.sleep(100)； &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; num--; &#125; else&#123; System.out.println(&quot;售完&quot;); break; &#125; &#125; &#125; &#125;&#125;public class Sale &#123; public static void main (String[] args)&#123; SaleWindow win1 = new SaleWindow(&quot;窗口1：&quot;); SaleWindow win2 = new SaleWindow(&quot;窗口2：&quot;); SaleWindow win3 = new SaleWindow(&quot;窗口3：&quot;); win1.start(); win2.start(); win3.start(); &#125;&#125; 2.同步方法：使用 synchronize 修饰一个方法： public synchronize void run() NOTE: 如果是一个非静态的同步函数的锁对象是this对象，如果是静态的同步函数的锁对象是当前函数所属的字节码字节（class对象) 同步函数的锁对象是固定的，不能自定义； C#中线程安全的解决方案： lock关键字 类似于Java中的同步代码块，lock(“锁”){执行代码} 。不同的是lock中的参数只能是引用类型，因为如果使用基本类型所谓锁，这每次都会发生装箱操作，则每次lock中都会重新new一个对象。 NOTE: 尽量不要在public的类中使用lock，因为如此使用此类时，在不知情的情况下则会很容易造成死锁 尽量不要用public的字段作为锁，也会容易造成死锁； 不要用一个字符串作为锁，因为字符串被CLR“暂留”，就是说整个应用程序中给定的字符串都只有一个实例，因此更容易造成死锁现象。 1234567891011121314151617181920212223242526272829303132333435class Demo2 &#123; static int num = 50; static object lockThe = new object(); static void Run() &#123; while (true) &#123; lock (lockThe) &#123; if (num &gt; 0) &#123; Console.WriteLine(Thread.CurrentThread.Name + &quot;销售了第：&quot; + num + &quot;票&quot;); try &#123; Thread.Sleep(100); &#125; catch (Exception e) &#123; Console.WriteLine(e.StackTrace); &#125; num--; &#125; else &#123; Console.WriteLine(&quot;售完..&quot;); break; &#125; &#125; &#125; &#125; public static void Main(string[] args) &#123; ThreadStart start = new ThreadStart(Run); Thread win1 = new Thread(start); Thread win2 = new Thread(start); win1.Name = &quot;第一个窗口&quot;; win2.Name = &quot;第二个窗口&quot;; win1.Start(); win2.Start(); Console.ReadKey(); &#125;&#125; Monitor Monitor与lock类似，lock(object){} 等效于 Monitor.Enter(object)……Monitor.Exit(object). 1234567891011lock (object)&#123; Run();&#125;等效于：Monitor.Enter(object);try&#123; Run();&#125;finally&#123; Monitor.Exit(object);&#125; Mutex Mutex也是与Monitor类似,不过Mutex 有一个很大的特点，Mutex是跨进程的（博主不是很懂，会深入学习）。 Interlocked 如果只是对整形数据进行简单的操作，可以使用Interlocked来实现同步。此类的方法有：Increment（ref i)（对整数加一个），Decrement(ref i)（对整数减一个）,Exchange(ref i , 100)与将i变为100，CompareExchange(ref i, 10 , 100),比较两个值，如果i与100相同，则i将变成10，否则不变。","categories":[{"name":"C#与Java","slug":"C-与Java","permalink":"http://yoursite.com/categories/C-与Java/"}],"tags":[{"name":"Java C#","slug":"Java-C","permalink":"http://yoursite.com/tags/Java-C/"}]},{"title":"多线程-Java与C#","slug":"多线程-Java与C","date":"2018-07-22T06:44:47.000Z","updated":"2019-01-17T10:50:46.701Z","comments":true,"path":"2018/07/22/多线程-Java与C/","link":"","permalink":"http://yoursite.com/2018/07/22/多线程-Java与C/","excerpt":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看:","text":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看: 1.新建一个线程Java创建线程： 一种方法是：自定义一个类，继承Thread类，且重写其中的run()方法：例如： 1234567891011121314public class NewThread extends Thread&#123; //继承Tread类 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewThread thread = new NewThread(); thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; 另一种方法是：自定义个一类，继承Runable接口，并重写接口中的run()方法：例如; 123456789101112131415public class NewRunable implement Runable&#123; //继承Runable接口 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewRunable runable = new NewRunable(); Thread thread = new Thread(runable,) thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; C#创建线程： ​ 通过创建一个Thread类接收一个ThreadStart委托或ParameterizedThreadStart委托，委托中包含新线程执行的的方法，例如： 123456789101112131415161718 class Program &#123; static void Main(string[] args) &#123; ThreadStart threadStart = new ThreadStart(Run); Thread thread = new Thread(threadStart); thread.Start(); for (int i = 0; i &lt; 100; i++) &#123; Console.WriteLine(&quot;this is main thread&quot; + i); &#125; Console.ReadKey(); &#125; //线程要 static void Run() &#123; for(int i = 0; i&lt;100; i++) &#123; Console.WriteLine(&quot;this is another thread&quot; + i); &#125; &#125; &#125;&#125; 2. 线程安全问题线程的生命周期： 创建 ——-&gt;start()——-&gt;可运行状态（具备等待CPU的资格，不具备CPU的执行权）——-&gt;得到CPU的执行权——–&gt;运行状态(具备等待CPU和CPU的执行资格)(运行状态和可运行状态可相互装换)——–&gt;完成任务——–&gt;死亡状态 12sleep(ms) : 进入临时阻塞状态,那么线程一旦超过了指定了睡眠时间，那么就会重新进入可运行状态，wait：需要其他线程唤醒该线程才可以重新进入可运行状态。 1引起线程安全问题的条件：1. 在多线程的环境下；2. 线程中有共享数据；3. 共享数据有多条语句操作，执行。 Java中线程安全问题的解决方案： 使用同步代码块， synchronize([锁对象]) (Note:锁对象可以是任何对象(object）,切是唯一共享的，否则无效。（最简单的定义一个锁可以使用 字符串） 我们使用一个比较典型的例子来实现此问题（售票窗口售票的问题） 12345678910111213141516171819202122232425262728293031323334class SaleWindow extends Thread&#123; public static int num = 50; //售票的剩余数 public SaleWindow(String name)&#123;super(name);&#125; @Override public void run()&#123; while(true)&#123; synchronized(&quot;lock&quot;)&#123; if(num &gt; 0)&#123; System.out.println(this.getName() + &quot;销售了第：&quot; + num + &quot;票&quot;); try&#123; Thread.sleep(100)； &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; num--; &#125; else&#123; System.out.println(&quot;售完&quot;); break; &#125; &#125; &#125; &#125;&#125;public class Sale &#123; public static void main (String[] args)&#123; SaleWindow win1 = new SaleWindow(&quot;窗口1：&quot;); SaleWindow win2 = new SaleWindow(&quot;窗口2：&quot;); SaleWindow win3 = new SaleWindow(&quot;窗口3：&quot;); win1.start(); win2.start(); win3.start(); &#125;&#125; 2.同步方法：使用 synchronize 修饰一个方法： public synchronize void run() NOTE: 如果是一个非静态的同步函数的锁对象是this对象，如果是静态的同步函数的锁对象是当前函数所属的字节码字节（class对象) 同步函数的锁对象是固定的，不能自定义； C#中线程安全的解决方案： lock关键字 类似于Java中的同步代码块，lock(“锁”){执行代码} 。不同的是lock中的参数只能是引用类型，因为如果使用基本类型所谓锁，这每次都会发生装箱操作，则每次lock中都会重新new一个对象。 NOTE: 尽量不要在public的类中使用lock，因为如此使用此类时，在不知情的情况下则会很容易造成死锁 尽量不要用public的字段作为锁，也会容易造成死锁； 不要用一个字符串作为锁，因为字符串被CLR“暂留”，就是说整个应用程序中给定的字符串都只有一个实例，因此更容易造成死锁现象。 1234567891011121314151617181920212223242526272829303132333435class Demo2 &#123; static int num = 50; static object lockThe = new object(); static void Run() &#123; while (true) &#123; lock (lockThe) &#123; if (num &gt; 0) &#123; Console.WriteLine(Thread.CurrentThread.Name + &quot;销售了第：&quot; + num + &quot;票&quot;); try &#123; Thread.Sleep(100); &#125; catch (Exception e) &#123; Console.WriteLine(e.StackTrace); &#125; num--; &#125; else &#123; Console.WriteLine(&quot;售完..&quot;); break; &#125; &#125; &#125; &#125; public static void Main(string[] args) &#123; ThreadStart start = new ThreadStart(Run); Thread win1 = new Thread(start); Thread win2 = new Thread(start); win1.Name = &quot;第一个窗口&quot;; win2.Name = &quot;第二个窗口&quot;; win1.Start(); win2.Start(); Console.ReadKey(); &#125;&#125; Monitor Monitor与lock类似，lock(object){} 等效于 Monitor.Enter(object)……Monitor.Exit(object). 1234567891011lock (object)&#123; Run();&#125;等效于：Monitor.Enter(object);try&#123; Run();&#125;finally&#123; Monitor.Exit(object);&#125; Mutex Mutex也是与Monitor类似,不过Mutex 有一个很大的特点，Mutex是跨进程的（博主不是很懂，会深入学习）。 Interlocked 如果只是对整形数据进行简单的操作，可以使用Interlocked来实现同步。此类的方法有：Increment（ref i)（对整数加一个），Decrement(ref i)（对整数减一个）,Exchange(ref i , 100)与将i变为100，CompareExchange(ref i, 10 , 100),比较两个值，如果i与100相同，则i将变成10，否则不变。","categories":[{"name":"C#与Java","slug":"C-与Java","permalink":"http://yoursite.com/categories/C-与Java/"}],"tags":[{"name":"Java C#","slug":"Java-C","permalink":"http://yoursite.com/tags/Java-C/"}]},{"title":"MarkDown体验","slug":"MarkDown体验","date":"2018-07-20T12:38:46.000Z","updated":"2018-09-30T15:33:38.105Z","comments":true,"path":"2018/07/20/MarkDown体验/","link":"","permalink":"http://yoursite.com/2018/07/20/MarkDown体验/","excerpt":"&emsp;&emsp;使用MarkDown编写文章，首先要学会MarkDown的一些简单的语法，以下就是自己学习的一些简单的MD语法：","text":"&emsp;&emsp;使用MarkDown编写文章，首先要学会MarkDown的一些简单的语法，以下就是自己学习的一些简单的MD语法： 1.标题语法： &emsp;&emsp;在MD中有6个级别的标题： 一级标题用一个’#‘号表示，输入一个’#‘+一个空格就可以表示一级标题；二级标题则用两个’#‘表示（##），以此类推直到第六个标题，例如： # 一级标题 ## 二级标题 ### 三级标题 。。。 也可在末尾也加上’#‘号 # 一级标题 ## 二级标题 如此和上面的标题展现出来是一样的，只是看起来比较美观而已。（Note：MD的语法符号和字符之间需要格空格） &emsp;&emsp;另一种标题语法是，再标题的下面输入‘=’或‘-’号，这种方式只能有两种等级的标题，例如： 一级标题 ======== 二级标题 --------- 关于‘=’和‘-’的符号个数随自己而定 &emsp;&emsp;MD还兼容HTML标签，所以标题也可以用HTML标签去展示标签‘&lt;h1&gt;&lt;/h1&gt;’ 例如： &lt;h1&gt;title&lt;/h1&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;h3&gt;title&lt;/h3&gt; 2.缩进和换行&emsp;&emsp;缩进直接用占位符表示 【1】 &amp;ensp;或&amp;#8194; //半角 【2】 &amp;emsp;或&amp;#8195; //全角 【3】 &amp;nbsp;或&amp;#160; &emsp;&emsp;换行可以使用和HTML标签br标签,或者使用两个空格加上回车，或者两次回车。 3.列表&emsp;&emsp;无序列表使用‘*’或者‘+’或者‘-’ 后面加一个空格来标记，例如： * 列表1 + 列表2 - 列表3 * 列表1 + 列表2 - 列表3 * 列表1 + 列表2 - 列表3 &emsp;&emsp;有序列表使用数字加一个半角字符的‘.’,例如： 1. 列表 2. 列表 3. 列表 4.表格 header 1 header 2 row 1 col 1 row 1 col 2 row 2 col 1 row 2 col 2 符号的展示，例如: header 1 | header 2 ---|--- row 1 col 1 | row 1 col 2 row 2 col 1 | row 2 col 2 5.代码块 可以用1个制表符表示在空行点击“tab”键或者4个空格。 用“`”包含住代码块中的字符。 6.图片 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字 ![image](/path/path/image.jpg &quot;title&quot;) 7.超链接http://www.google.com/&#x61;&#x64;&#x64;&#114;&#101;&#115;&#x73;&#69;&#x6d;&#x61;&#x69;&#108;&#x40;&#x65;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;符号展示如下： &lt;http://www.google.com/&gt; &lt;addressEmail@email.com&gt; 8.一些字体强调 加粗 **加粗** 斜体 ***斜体*** 以上的所有标记都可以用HTML表示","categories":[{"name":"MD语法","slug":"MD语法","permalink":"http://yoursite.com/categories/MD语法/"}],"tags":[{"name":"MD语法","slug":"MD语法","permalink":"http://yoursite.com/tags/MD语法/"}]}]}