{"meta":{"title":"WxhShine","subtitle":null,"description":null,"author":"XiaoHui","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Log4Net--日志记录","slug":"Log4Net-日志记录","date":"2018-09-23T12:39:29.000Z","updated":"2018-09-30T15:43:18.684Z","comments":true,"path":"2018/09/23/Log4Net-日志记录/","link":"","permalink":"http://yoursite.com/2018/09/23/Log4Net-日志记录/","excerpt":"","text":"","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"Spring.Net--控制反转","slug":"Spring-Net-控制反转","date":"2018-09-15T12:38:46.000Z","updated":"2018-09-30T15:48:15.608Z","comments":true,"path":"2018/09/15/Spring-Net-控制反转/","link":"","permalink":"http://yoursite.com/2018/09/15/Spring-Net-控制反转/","excerpt":"","text":"","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Memcache--分布式缓存","slug":"Memcache-分布式缓存","date":"2018-09-02T12:40:59.000Z","updated":"2018-09-30T15:47:30.355Z","comments":true,"path":"2018/09/02/Memcache-分布式缓存/","link":"","permalink":"http://yoursite.com/2018/09/02/Memcache-分布式缓存/","excerpt":"","text":"","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"cache","slug":"cache","permalink":"http://yoursite.com/tags/cache/"}]},{"title":"C#中的匿名类型","slug":"Csharp中的匿名类型","date":"2018-08-15T08:14:16.000Z","updated":"2018-09-30T15:47:51.827Z","comments":true,"path":"2018/08/15/Csharp中的匿名类型/","link":"","permalink":"http://yoursite.com/2018/08/15/Csharp中的匿名类型/","excerpt":"​ 在一个项目中遇到了一个关于匿名类型的坑","text":"​ 在一个项目中遇到了一个关于匿名类型的坑 在C#中的匿名类型是这样创建的： 1new &#123;Id = 1, Name = &quot;Tom&quot;, Psw = &quot;123&quot;&#125;; 而这些匿名类型的属性是internal的，所以是只有在同一程序集才能使用。 ​ 在一个项目中我使用了dynamic去声明了一个参数，并且跨程序集调用了此方法，则会抛出异常： Microsoft.CSharp.RuntimeBinder.RuntimeBinderException ：object类中未包含Id的定义 12345678910111213141516171819202122232425//在一个项目添加此代码using System;namespace DynamicDemo &#123; class Program &#123; static void Main(string[] args) &#123; var user = new &#123; Id = 1, name = &quot;Tom&quot;, psw = &quot;123&quot; &#125;; LoginInter(user); Demo.Demo.Login(user); Console.ReadKey(); &#125; public static void LoginInter(dynamic user) &#123; Console.Write(user.Id + user.name + user.psw); &#125; &#125;&#125;//在另一个项目中添加此代码 生成的程序集是Demo.dllusing System;namespace Demo &#123; public class Demo &#123; public static void Login(dynamic user) &#123; Console.Write(user.Id + user.name + user.psw);//抛出异常 &#125; &#125;&#125; public 关键字是类型和类型成员的访问修饰符。公共访问是允许的最高访问级别，对访问公共成员没有限制。 protected 关键字是一个成员访问修饰符。受保护成员在它的类中可访问并且可由派生类访问。 private 关键字是一个成员访问修饰符。私有访问是允许的最低访问级别。私有成员只有在声明它们的类和结构体中才是可访问的。 internal 关键字是类型和类型成员的访问修饰符。只有在同一程序集的文件中，内部类型或成员才是可访问的。","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"多线程-Java与CSharp","slug":"多线程-Java与CSharp","date":"2018-07-22T06:44:47.000Z","updated":"2018-09-30T15:37:55.907Z","comments":true,"path":"2018/07/22/多线程-Java与CSharp/","link":"","permalink":"http://yoursite.com/2018/07/22/多线程-Java与CSharp/","excerpt":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看:","text":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看: 1.新建一个线程Java创建线程： 一种方法是：自定义一个类，继承Thread类，且重写其中的run()方法：例如： 1234567891011121314public class NewThread extends Thread&#123; //继承Tread类 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewThread thread = new NewThread(); thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; 另一种方法是：自定义个一类，继承Runable接口，并重写接口中的run()方法：例如; 123456789101112131415public class NewRunable implement Runable&#123; //继承Runable接口 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewRunable runable = new NewRunable(); Thread thread = new Thread(runable,) thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; C#创建线程：​ 通过创建一个Thread类接收一个ThreadStart委托或ParameterizedThreadStart委托，委托中包含新线程执行的的方法，例如： 123456789101112131415161718 class Program &#123; static void Main(string[] args) &#123; ThreadStart threadStart = new ThreadStart(Run); Thread thread = new Thread(threadStart); thread.Start(); for (int i = 0; i &lt; 100; i++) &#123; Console.WriteLine(&quot;this is main thread&quot; + i); &#125; Console.ReadKey(); &#125; //线程要 static void Run() &#123; for(int i = 0; i&lt;100; i++) &#123; Console.WriteLine(&quot;this is another thread&quot; + i); &#125; &#125; &#125;&#125; 2. 线程安全问题线程的生命周期：创建 ——-&gt;start()——-&gt;可运行状态（具备等待CPU的资格，不具备CPU的执行权）——-&gt;得到CPU的执行权——–&gt;运行状态(具备等待CPU和CPU的执行资格)(运行状态和可运行状态可相互装换)——–&gt;完成任务——–&gt;死亡状态 12sleep(ms) : 进入临时阻塞状态,那么线程一旦超过了指定了睡眠时间，那么就会重新进入可运行状态，wait：需要其他线程唤醒该线程才可以重新进入可运行状态。 引起线程安全问题的条件：1. 在多线程的环境下；2. 线程中有共享数据；3. 共享数据有多条语句操作，执行。 Java中线程安全问题的解决方案： 使用同步代码块， synchronize([锁对象]) (Note:锁对象可以是任何对象(object）,切是唯一共享的，否则无效。（最简单的定义一个锁可以使用 字符串） 我们使用一个比较典型的例子来实现此问题（售票窗口售票的问题） 12345678910111213141516171819202122232425262728293031323334class SaleWindow extends Thread&#123; public static int num = 50; //售票的剩余数 public SaleWindow(String name)&#123;super(name);&#125; @Override public void run()&#123; while(true)&#123; synchronized(&quot;lock&quot;)&#123; if(num &gt; 0)&#123; System.out.println(this.getName() + &quot;销售了第：&quot; + num + &quot;票&quot;); try&#123; Thread.sleep(100)； &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; num--; &#125; else&#123; System.out.println(&quot;售完&quot;); break; &#125; &#125; &#125; &#125;&#125;public class Sale &#123; public static void main (String[] args)&#123; SaleWindow win1 = new SaleWindow(&quot;窗口1：&quot;); SaleWindow win2 = new SaleWindow(&quot;窗口2：&quot;); SaleWindow win3 = new SaleWindow(&quot;窗口3：&quot;); win1.start(); win2.start(); win3.start(); &#125;&#125; 2.同步方法：使用 synchronize 修饰一个方法： public synchronize void run() NOTE: 如果是一个非静态的同步函数的锁对象是this对象，如果是静态的同步函数的锁对象是当前函数所属的字节码字节（class对象) 同步函数的锁对象是固定的，不能自定义； C#中线程安全的解决方案： lock关键字 类似于Java中的同步代码块，lock(“锁”){执行代码} 。不同的是lock中的参数只能是引用类型，因为如果使用基本类型所谓锁，这每次都会发生装箱操作，则每次lock中都会重新new一个对象。 NOTE: 尽量不要在public的类中使用lock，因为如此使用此类时，在不知情的情况下则会很容易造成死锁 尽量不要用public的字段作为锁，也会容易造成死锁； 不要用一个字符串作为锁，因为字符串被CLR“暂留”，就是说整个应用程序中给定的字符串都只有一个实例，因此更容易造成死锁现象。 1234567891011121314151617181920212223242526272829303132333435class Demo2 &#123; static int num = 50; static object lockThe = new object(); static void Run() &#123; while (true) &#123; lock (lockThe) &#123; if (num &gt; 0) &#123; Console.WriteLine(Thread.CurrentThread.Name + &quot;销售了第：&quot; + num + &quot;票&quot;); try &#123; Thread.Sleep(100); &#125; catch (Exception e) &#123; Console.WriteLine(e.StackTrace); &#125; num--; &#125; else &#123; Console.WriteLine(&quot;售完..&quot;); break; &#125; &#125; &#125; &#125; public static void Main(string[] args) &#123; ThreadStart start = new ThreadStart(Run); Thread win1 = new Thread(start); Thread win2 = new Thread(start); win1.Name = &quot;第一个窗口&quot;; win2.Name = &quot;第二个窗口&quot;; win1.Start(); win2.Start(); Console.ReadKey(); &#125;&#125; Monitor Monitor与lock类似，lock(object){} 等效于 Monitor.Enter(object)……Monitor.Exit(object). 1234567891011lock (object)&#123; Run();&#125;等效于：Monitor.Enter(object);try&#123; Run();&#125;finally&#123; Monitor.Exit(object);&#125; Mutex Mutex也是与Monitor类似,不过Mutex 有一个很大的特点，Mutex是跨进程的（博主不是很懂，会深入学习）。 Interlocked 如果只是对整形数据进行简单的操作，可以使用Interlocked来实现同步。此类的方法有：Increment（ref i)（对整数加一个），Decrement(ref i)（对整数减一个）,Exchange(ref i , 100)与将i变为100，CompareExchange(ref i, 10 , 100),比较两个值，如果i与100相同，则i将变成10，否则不变。","categories":[{"name":"C#与Java","slug":"C-与Java","permalink":"http://yoursite.com/categories/C-与Java/"}],"tags":[{"name":"Java C#","slug":"Java-C","permalink":"http://yoursite.com/tags/Java-C/"}]},{"title":"MarkDown体验","slug":"MarkDown体验","date":"2018-07-20T12:38:46.000Z","updated":"2018-09-30T15:33:38.105Z","comments":true,"path":"2018/07/20/MarkDown体验/","link":"","permalink":"http://yoursite.com/2018/07/20/MarkDown体验/","excerpt":"&emsp;&emsp;使用MarkDown编写文章，首先要学会MarkDown的一些简单的语法，以下就是自己学习的一些简单的MD语法：","text":"&emsp;&emsp;使用MarkDown编写文章，首先要学会MarkDown的一些简单的语法，以下就是自己学习的一些简单的MD语法： 1.标题语法： &emsp;&emsp;在MD中有6个级别的标题： 一级标题用一个’#‘号表示，输入一个’#‘+一个空格就可以表示一级标题；二级标题则用两个’#‘表示（##），以此类推直到第六个标题，例如： # 一级标题 ## 二级标题 ### 三级标题 。。。 也可在末尾也加上’#‘号 # 一级标题 ## 二级标题 如此和上面的标题展现出来是一样的，只是看起来比较美观而已。（Note：MD的语法符号和字符之间需要格空格） &emsp;&emsp;另一种标题语法是，再标题的下面输入‘=’或‘-’号，这种方式只能有两种等级的标题，例如： 一级标题 ======== 二级标题 --------- 关于‘=’和‘-’的符号个数随自己而定 &emsp;&emsp;MD还兼容HTML标签，所以标题也可以用HTML标签去展示标签‘&lt;h1&gt;&lt;/h1&gt;’ 例如： &lt;h1&gt;title&lt;/h1&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;h3&gt;title&lt;/h3&gt; 2.缩进和换行&emsp;&emsp;缩进直接用占位符表示 【1】 &amp;ensp;或&amp;#8194; //半角 【2】 &amp;emsp;或&amp;#8195; //全角 【3】 &amp;nbsp;或&amp;#160; &emsp;&emsp;换行可以使用和HTML标签br标签,或者使用两个空格加上回车，或者两次回车。 3.列表&emsp;&emsp;无序列表使用‘*’或者‘+’或者‘-’ 后面加一个空格来标记，例如： * 列表1 + 列表2 - 列表3 * 列表1 + 列表2 - 列表3 * 列表1 + 列表2 - 列表3 &emsp;&emsp;有序列表使用数字加一个半角字符的‘.’,例如： 1. 列表 2. 列表 3. 列表 4.表格 header 1 header 2 row 1 col 1 row 1 col 2 row 2 col 1 row 2 col 2 符号的展示，例如: header 1 | header 2 ---|--- row 1 col 1 | row 1 col 2 row 2 col 1 | row 2 col 2 5.代码块 可以用1个制表符表示在空行点击“tab”键或者4个空格。 用“`”包含住代码块中的字符。 6.图片 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字 ![image](/path/path/image.jpg &quot;title&quot;) 7.超链接http://www.google.com/&#97;&#x64;&#100;&#114;&#x65;&#x73;&#115;&#x45;&#x6d;&#97;&#105;&#x6c;&#x40;&#x65;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;符号展示如下： &lt;http://www.google.com/&gt; &lt;addressEmail@email.com&gt; 8.一些字体强调 加粗 **加粗** 斜体 ***斜体*** 以上的所有标记都可以用HTML表示","categories":[{"name":"MD语法","slug":"MD语法","permalink":"http://yoursite.com/categories/MD语法/"}],"tags":[{"name":"MD语法","slug":"MD语法","permalink":"http://yoursite.com/tags/MD语法/"}]}]}