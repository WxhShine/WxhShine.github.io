{"meta":{"title":"WxhShine","subtitle":null,"description":null,"author":"XiaoHui","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"EF-CodeFirst:建表时单复数形式","slug":"EF-CodeFirst-建表时单复数形式","date":"2018-10-03T06:28:34.000Z","updated":"2018-10-03T06:28:34.934Z","comments":true,"path":"2018/10/03/EF-CodeFirst-建表时单复数形式/","link":"","permalink":"http://yoursite.com/2018/10/03/EF-CodeFirst-建表时单复数形式/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"EF-CodeFirst模式","slug":"EF-CodeFirst模式","date":"2018-10-03T06:27:14.000Z","updated":"2018-10-03T06:30:08.636Z","comments":true,"path":"2018/10/03/EF-CodeFirst模式/","link":"","permalink":"http://yoursite.com/2018/10/03/EF-CodeFirst模式/","excerpt":"","text":"","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C# , EF","slug":"C-EF","permalink":"http://yoursite.com/tags/C-EF/"}]},{"title":"Log4Net--日志记录","slug":"Log4Net-日志记录","date":"2018-09-23T12:39:29.000Z","updated":"2018-10-06T15:25:07.358Z","comments":true,"path":"2018/09/23/Log4Net-日志记录/","link":"","permalink":"http://yoursite.com/2018/09/23/Log4Net-日志记录/","excerpt":"​ Log4Net是用来记录日志的，可以将程序运行过程中的信息输出到一些地方（文件、数据库、EventLog等），日志就是程序的黑匣子，可以通过日志查看系统的运行过程，从而发现系统的问题。日志的作用：将运行过程的步骤、成功失败记录下来，将关键性的数据记录下来分析系统问题所在。​ 对于网站来讲，不能把异常信息显示给用户，异常信息只能记录到日志，出了问题把日志文件发给开发人员，就能知道问题所在。","text":"​ Log4Net是用来记录日志的，可以将程序运行过程中的信息输出到一些地方（文件、数据库、EventLog等），日志就是程序的黑匣子，可以通过日志查看系统的运行过程，从而发现系统的问题。日志的作用：将运行过程的步骤、成功失败记录下来，将关键性的数据记录下来分析系统问题所在。​ 对于网站来讲，不能把异常信息显示给用户，异常信息只能记录到日志，出了问题把日志文件发给开发人员，就能知道问题所在。 ​ 第一步: 建立一个简单的日志记录程序; ​ 第二步: 添加对Log4net.dll的引用,可以通过NuGet导入,也可以通过官网http://logging.apache.org/log4net/下载; ​ 第三步: 将Log4Net的配置信息加入到程序中的配置文件.config中如下:(更多详细信息请查看官网.) 12345678910111213141516171819202122232425&lt;!--Log4Net配置--&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/&gt; &lt;/configSections&gt; &lt;log4net&gt; &lt;!-- Define some output appenders --&gt; &lt;appender name=\"RollingLogFileAppender\" type=\"log4net.Appender.RollingFileAppender\"&gt;&lt;!--type:表示将日志记录到滚动文件中,其中,AdoNetAppender(记录到数据库中),SmtpAppender(邮件),ConsoleAppender(控制台显示日志),EventLogAppender(Windows事件日志)--&gt; &lt;file value=\"test.txt\"/&gt;&lt;!--日志存放位置--&gt; &lt;appendToFile value=\"true\"/&gt;&lt;!--日志内容是否追加在文件中,false表示覆盖之前内容--&gt; &lt;maxSizeRollBackups value=\"10\"/&gt;&lt;!--当文件数据量超过存储量,则新建文件,属性表示最多备份多少文件--&gt; &lt;maximumFileSize value=\"1024KB\"/&gt;&lt;!--最大存储数据量--&gt; &lt;rollingStyle value=\"Size\"/&gt;&lt;!--滚动备份的方式,Size表示文件大小,Date表示日期--&gt; &lt;staticLogFileName value=\"true\"/&gt;&lt;!--日志文件名是否静态 --&gt; &lt;layout type=\"log4net.Layout.PatternLayout\"&gt; &lt;conversionPattern value=\"%date [%thread] %-5level %logger - %message%newline\"/&gt;&lt;!--表示输出格式:记录时间,线程Id,日志级别,出错类,错误描述,换行--&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;level value=\"ERROR\"/&gt;&lt;!--日志等级:None&gt;Fatal&gt;ERROR&gt;WARN&gt;DEBUG&gt;INFO&gt;ALL.如果日志级别低于此value级别,则不会记录--&gt; &lt;appender-ref ref=\"RollingLogFileAppender\"/&gt; &lt;/root&gt; &lt;!--可以设置多个Appender将日志信息分别记录到不同地方--&gt; &lt;/log4net&gt;&lt;/configuration&gt; ​ 第四步: 初始化Log4Net. 在程序最开始就初始化.log4net.Config.Xmlconfigtor.Configure();(读取配置文件中的配置信息); ​ 第五步: 在需要打印日志的地方 1234567891011 ILog log = log4net.LogManager.GetLogger(&quot;&quot;); //错误信息 log.Error(&quot;error&quot;,new Exception(&quot;错误异常信息&quot;));//崩溃信息 log.Fatal(&quot;fatal&quot;,new Exception(&quot;发生了一个致命错误&quot;));//记录一般信息 log.Info(&quot;info&quot;); //记录调试信息 log.Debug(&quot;debug&quot;); //记录警告信息 log.Warn(&quot;warn&quot;); 以上就是log4net基本应用方式","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"Spring.Net--控制反转","slug":"Spring-Net-控制反转","date":"2018-09-15T12:38:46.000Z","updated":"2018-10-10T15:56:03.818Z","comments":true,"path":"2018/09/15/Spring-Net-控制反转/","link":"","permalink":"http://yoursite.com/2018/09/15/Spring-Net-控制反转/","excerpt":"","text":"​ Spring.Net 为建立企业级应用提供了一套轻量级的解决方案。通过Spring.NET，我们可以用统一且透明的方式来配置应用程序。Spring.NET的重点是为中间层提供声明式事务管理，以及一个功能齐全的ASP.NET扩展框架。Spring.NET是非侵入式的，代码对框架本身不会产生任何依赖. ​ Spring.Net 就是抽象工厂模式 , 它使用配置文件的方式,去是实现了控制反转, 控制反转就是通过依赖注入的方式是对象A不需要使用new对象B, 而是通过容器的方式,将对象B注入到对象A的应用. 通过简单的例子来介绍Spring.Net简单的使用: 第一步 : 先新建一个控制台程序; 第二步 : 引入Spring.Net文件,可用在NuGet中搜索,下载.也可以在官网中下载并在项目引用相关.dll文件; 第三步 : 接下来就是创建相关的类文件 123456789101112using System;namespace SpringdotNetDemo &#123; public class Service1 &#123; public string Name &#123; get; set; &#125; public Service2 Service &#123; get; set; &#125; public void Show() &#123; Service.Show(); Console.WriteLine(&quot;Spring.Net:&quot; + Name); &#125; &#125;&#125; 123456789using System;namespace SpringdotNetDemo &#123; public class Service2 &#123; public void Show() &#123; Console.WriteLine(&quot;Service2&quot;); &#125; &#125;&#125; 第四步 : 在App.Config中配置Spring.Net 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;!--Spring.Net节点配置--&gt; &lt;sectionGroup name=\"spring\"&gt; &lt;section name=\"context\" type=\"Spring.Context.Support.ContextHandler, Spring.Core\"/&gt; &lt;section name=\"objects\" type=\"Spring.Context.Support.DefaultSectionHandler, Spring.Core\" /&gt; &lt;/sectionGroup&gt; &lt;/configSections&gt; &lt;startup&gt; &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.6.1\" /&gt; &lt;/startup&gt; &lt;!--Spring.Net 配置--&gt; &lt;spring&gt; &lt;context&gt; &lt;!--容器配置--&gt; &lt;resource uri=\"config://spring/objects\"/&gt; &lt;!--可以将objects节点的配置保存在xml文件，更改文件更改属性，复制到输出目录：始终复制--&gt; &lt;!--&lt;resource uri=\"file://objects.xml\"/&gt;--&gt; &lt;/context&gt; &lt;objects xmlns=\"http://www.springframework.net\"&gt; &lt;!--这里放容器里面的所有节点--&gt; &lt;description&gt;An example that demonstrates simple IoC features.&lt;/description&gt; &lt;!--name 必须要唯一的，type=类的全名称，所在的程序集--&gt; &lt;object name=\"Service1\" type=\"SpringdotNetDemo.Serive1, SpringdotNetDemo\"&gt; &lt;!--设置Service1中属性的值--&gt; &lt;property name=\"Name\" value=\"Service1.Name\"/&gt; &lt;property name=\"Service\" ref=\"Service2\"/&gt; &lt;/object&gt; &lt;object name=\"Service2\" type=\"SpringdotNetDemo.Serive2, SpringdotNetDemo\"&gt;&lt;/object&gt; &lt;/objects&gt; &lt;/spring&gt;&lt;/configuration&gt; 第五步 : 在主函数中应用配置: 1234567891011121314151617using Spring.Context;using Spring.Context.Support;using System;namespace SpringdotNetDemo &#123; class Program &#123; static void Main(string[] args) &#123; //Spring.Net 创建实例的方式转为容器帮我们创建 //创建spring容器上下文 IApplicationContext context = ContextRegistry.GetContext(); //通过容器创建对象 var ser = context.GetObject(&quot;Service1&quot;) as Service1; ser.Show(); Console.ReadKey(); &#125; &#125;&#125; 其运行结果: 以上就是Spring.Net的简单应用","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Memcache--分布式缓存","slug":"Memcache-分布式缓存","date":"2018-09-02T12:40:59.000Z","updated":"2018-10-20T08:13:23.613Z","comments":true,"path":"2018/09/02/Memcache-分布式缓存/","link":"","permalink":"http://yoursite.com/2018/09/02/Memcache-分布式缓存/","excerpt":"","text":"MemCache简介​ MemCache 是一个分布式的告诉缓存系统, 可以显著提高网站的访问速度,减少对数据库的访问. MemCache是一套开源代码.可以在GitHub上下载或者在官网上下载. ​ MemCache 的工作流程如下：先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）；每次更新数据库的同时更新memcached中的数据，保证一致性；当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据 ​ Memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。 ​ Memcache是danga的一个项目，最早是LiveJournal 服务的，最初为了加速 LiveJournal 访问速度而开发的，后来被很多大型的网站采用。 ​ Memcached是以守护程序(监听)方式运行于一个或多个服务器中，随时会接收客户端的连接和操作。 MemCache特性 在内存足够下的情况下Memcache中保存的item数据量是不受限制的;(Memcache单进程在32位系统下最大使用内存为2G,64位系统没有此限制) 最大30天的的数据过期时间, 由常量REALTIME_MAXDELTA 控制; 最大键长为250字节, 由常量KEY_MAX_LENGTH 控制; 单个Item最大的数据是1MB, 超过1MB的数据不存储, 由常量 POWER_BLOCK 控制","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"cache","slug":"cache","permalink":"http://yoursite.com/tags/cache/"}]},{"title":"C#中的匿名类型","slug":"Csharp中的匿名类型","date":"2018-08-15T08:14:16.000Z","updated":"2018-09-30T15:47:51.827Z","comments":true,"path":"2018/08/15/Csharp中的匿名类型/","link":"","permalink":"http://yoursite.com/2018/08/15/Csharp中的匿名类型/","excerpt":"​ 在一个项目中遇到了一个关于匿名类型的坑","text":"​ 在一个项目中遇到了一个关于匿名类型的坑 在C#中的匿名类型是这样创建的： 1new &#123;Id = 1, Name = &quot;Tom&quot;, Psw = &quot;123&quot;&#125;; 而这些匿名类型的属性是internal的，所以是只有在同一程序集才能使用。 ​ 在一个项目中我使用了dynamic去声明了一个参数，并且跨程序集调用了此方法，则会抛出异常： Microsoft.CSharp.RuntimeBinder.RuntimeBinderException ：object类中未包含Id的定义 12345678910111213141516171819202122232425//在一个项目添加此代码using System;namespace DynamicDemo &#123; class Program &#123; static void Main(string[] args) &#123; var user = new &#123; Id = 1, name = &quot;Tom&quot;, psw = &quot;123&quot; &#125;; LoginInter(user); Demo.Demo.Login(user); Console.ReadKey(); &#125; public static void LoginInter(dynamic user) &#123; Console.Write(user.Id + user.name + user.psw); &#125; &#125;&#125;//在另一个项目中添加此代码 生成的程序集是Demo.dllusing System;namespace Demo &#123; public class Demo &#123; public static void Login(dynamic user) &#123; Console.Write(user.Id + user.name + user.psw);//抛出异常 &#125; &#125;&#125; public 关键字是类型和类型成员的访问修饰符。公共访问是允许的最高访问级别，对访问公共成员没有限制。 protected 关键字是一个成员访问修饰符。受保护成员在它的类中可访问并且可由派生类访问。 private 关键字是一个成员访问修饰符。私有访问是允许的最低访问级别。私有成员只有在声明它们的类和结构体中才是可访问的。 internal 关键字是类型和类型成员的访问修饰符。只有在同一程序集的文件中，内部类型或成员才是可访问的。","categories":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"多线程-Java与CSharp","slug":"多线程-Java与CSharp","date":"2018-07-22T06:44:47.000Z","updated":"2018-09-30T15:37:55.907Z","comments":true,"path":"2018/07/22/多线程-Java与CSharp/","link":"","permalink":"http://yoursite.com/2018/07/22/多线程-Java与CSharp/","excerpt":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看:","text":"​ C#和Java中的多线程有相同之处，和不同之处。接下来请看: 1.新建一个线程Java创建线程： 一种方法是：自定义一个类，继承Thread类，且重写其中的run()方法：例如： 1234567891011121314public class NewThread extends Thread&#123; //继承Tread类 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewThread thread = new NewThread(); thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; 另一种方法是：自定义个一类，继承Runable接口，并重写接口中的run()方法：例如; 123456789101112131415public class NewRunable implement Runable&#123; //继承Runable接口 @Override //重写run()方法 public void run()&#123; for(int i = 0; i &lt; 100; i++) System.out.println(&quot;this is another thread&quot; + i); &#125; public static void main (String[] args[])&#123; NewRunable runable = new NewRunable(); Thread thread = new Thread(runable,) thread.start(); //自定义线程开始。 for(int i = 0; i&lt;100; i++)&#123; System.out.println(&quot;this is main thread&quot; + i)； &#125; &#125;&#125; C#创建线程：​ 通过创建一个Thread类接收一个ThreadStart委托或ParameterizedThreadStart委托，委托中包含新线程执行的的方法，例如： 123456789101112131415161718 class Program &#123; static void Main(string[] args) &#123; ThreadStart threadStart = new ThreadStart(Run); Thread thread = new Thread(threadStart); thread.Start(); for (int i = 0; i &lt; 100; i++) &#123; Console.WriteLine(&quot;this is main thread&quot; + i); &#125; Console.ReadKey(); &#125; //线程要 static void Run() &#123; for(int i = 0; i&lt;100; i++) &#123; Console.WriteLine(&quot;this is another thread&quot; + i); &#125; &#125; &#125;&#125; 2. 线程安全问题线程的生命周期：创建 ——-&gt;start()——-&gt;可运行状态（具备等待CPU的资格，不具备CPU的执行权）——-&gt;得到CPU的执行权——–&gt;运行状态(具备等待CPU和CPU的执行资格)(运行状态和可运行状态可相互装换)——–&gt;完成任务——–&gt;死亡状态 12sleep(ms) : 进入临时阻塞状态,那么线程一旦超过了指定了睡眠时间，那么就会重新进入可运行状态，wait：需要其他线程唤醒该线程才可以重新进入可运行状态。 引起线程安全问题的条件：1. 在多线程的环境下；2. 线程中有共享数据；3. 共享数据有多条语句操作，执行。 Java中线程安全问题的解决方案： 使用同步代码块， synchronize([锁对象]) (Note:锁对象可以是任何对象(object）,切是唯一共享的，否则无效。（最简单的定义一个锁可以使用 字符串） 我们使用一个比较典型的例子来实现此问题（售票窗口售票的问题） 12345678910111213141516171819202122232425262728293031323334class SaleWindow extends Thread&#123; public static int num = 50; //售票的剩余数 public SaleWindow(String name)&#123;super(name);&#125; @Override public void run()&#123; while(true)&#123; synchronized(&quot;lock&quot;)&#123; if(num &gt; 0)&#123; System.out.println(this.getName() + &quot;销售了第：&quot; + num + &quot;票&quot;); try&#123; Thread.sleep(100)； &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; num--; &#125; else&#123; System.out.println(&quot;售完&quot;); break; &#125; &#125; &#125; &#125;&#125;public class Sale &#123; public static void main (String[] args)&#123; SaleWindow win1 = new SaleWindow(&quot;窗口1：&quot;); SaleWindow win2 = new SaleWindow(&quot;窗口2：&quot;); SaleWindow win3 = new SaleWindow(&quot;窗口3：&quot;); win1.start(); win2.start(); win3.start(); &#125;&#125; 2.同步方法：使用 synchronize 修饰一个方法： public synchronize void run() NOTE: 如果是一个非静态的同步函数的锁对象是this对象，如果是静态的同步函数的锁对象是当前函数所属的字节码字节（class对象) 同步函数的锁对象是固定的，不能自定义； C#中线程安全的解决方案： lock关键字 类似于Java中的同步代码块，lock(“锁”){执行代码} 。不同的是lock中的参数只能是引用类型，因为如果使用基本类型所谓锁，这每次都会发生装箱操作，则每次lock中都会重新new一个对象。 NOTE: 尽量不要在public的类中使用lock，因为如此使用此类时，在不知情的情况下则会很容易造成死锁 尽量不要用public的字段作为锁，也会容易造成死锁； 不要用一个字符串作为锁，因为字符串被CLR“暂留”，就是说整个应用程序中给定的字符串都只有一个实例，因此更容易造成死锁现象。 1234567891011121314151617181920212223242526272829303132333435class Demo2 &#123; static int num = 50; static object lockThe = new object(); static void Run() &#123; while (true) &#123; lock (lockThe) &#123; if (num &gt; 0) &#123; Console.WriteLine(Thread.CurrentThread.Name + &quot;销售了第：&quot; + num + &quot;票&quot;); try &#123; Thread.Sleep(100); &#125; catch (Exception e) &#123; Console.WriteLine(e.StackTrace); &#125; num--; &#125; else &#123; Console.WriteLine(&quot;售完..&quot;); break; &#125; &#125; &#125; &#125; public static void Main(string[] args) &#123; ThreadStart start = new ThreadStart(Run); Thread win1 = new Thread(start); Thread win2 = new Thread(start); win1.Name = &quot;第一个窗口&quot;; win2.Name = &quot;第二个窗口&quot;; win1.Start(); win2.Start(); Console.ReadKey(); &#125;&#125; Monitor Monitor与lock类似，lock(object){} 等效于 Monitor.Enter(object)……Monitor.Exit(object). 1234567891011lock (object)&#123; Run();&#125;等效于：Monitor.Enter(object);try&#123; Run();&#125;finally&#123; Monitor.Exit(object);&#125; Mutex Mutex也是与Monitor类似,不过Mutex 有一个很大的特点，Mutex是跨进程的（博主不是很懂，会深入学习）。 Interlocked 如果只是对整形数据进行简单的操作，可以使用Interlocked来实现同步。此类的方法有：Increment（ref i)（对整数加一个），Decrement(ref i)（对整数减一个）,Exchange(ref i , 100)与将i变为100，CompareExchange(ref i, 10 , 100),比较两个值，如果i与100相同，则i将变成10，否则不变。","categories":[{"name":"C#与Java","slug":"C-与Java","permalink":"http://yoursite.com/categories/C-与Java/"}],"tags":[{"name":"Java C#","slug":"Java-C","permalink":"http://yoursite.com/tags/Java-C/"}]},{"title":"MarkDown体验","slug":"MarkDown体验","date":"2018-07-20T12:38:46.000Z","updated":"2018-09-30T15:33:38.105Z","comments":true,"path":"2018/07/20/MarkDown体验/","link":"","permalink":"http://yoursite.com/2018/07/20/MarkDown体验/","excerpt":"&emsp;&emsp;使用MarkDown编写文章，首先要学会MarkDown的一些简单的语法，以下就是自己学习的一些简单的MD语法：","text":"&emsp;&emsp;使用MarkDown编写文章，首先要学会MarkDown的一些简单的语法，以下就是自己学习的一些简单的MD语法： 1.标题语法： &emsp;&emsp;在MD中有6个级别的标题： 一级标题用一个’#‘号表示，输入一个’#‘+一个空格就可以表示一级标题；二级标题则用两个’#‘表示（##），以此类推直到第六个标题，例如： # 一级标题 ## 二级标题 ### 三级标题 。。。 也可在末尾也加上’#‘号 # 一级标题 ## 二级标题 如此和上面的标题展现出来是一样的，只是看起来比较美观而已。（Note：MD的语法符号和字符之间需要格空格） &emsp;&emsp;另一种标题语法是，再标题的下面输入‘=’或‘-’号，这种方式只能有两种等级的标题，例如： 一级标题 ======== 二级标题 --------- 关于‘=’和‘-’的符号个数随自己而定 &emsp;&emsp;MD还兼容HTML标签，所以标题也可以用HTML标签去展示标签‘&lt;h1&gt;&lt;/h1&gt;’ 例如： &lt;h1&gt;title&lt;/h1&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;h3&gt;title&lt;/h3&gt; 2.缩进和换行&emsp;&emsp;缩进直接用占位符表示 【1】 &amp;ensp;或&amp;#8194; //半角 【2】 &amp;emsp;或&amp;#8195; //全角 【3】 &amp;nbsp;或&amp;#160; &emsp;&emsp;换行可以使用和HTML标签br标签,或者使用两个空格加上回车，或者两次回车。 3.列表&emsp;&emsp;无序列表使用‘*’或者‘+’或者‘-’ 后面加一个空格来标记，例如： * 列表1 + 列表2 - 列表3 * 列表1 + 列表2 - 列表3 * 列表1 + 列表2 - 列表3 &emsp;&emsp;有序列表使用数字加一个半角字符的‘.’,例如： 1. 列表 2. 列表 3. 列表 4.表格 header 1 header 2 row 1 col 1 row 1 col 2 row 2 col 1 row 2 col 2 符号的展示，例如: header 1 | header 2 ---|--- row 1 col 1 | row 1 col 2 row 2 col 1 | row 2 col 2 5.代码块 可以用1个制表符表示在空行点击“tab”键或者4个空格。 用“`”包含住代码块中的字符。 6.图片 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字 ![image](/path/path/image.jpg &quot;title&quot;) 7.超链接http://www.google.com/&#97;&#x64;&#100;&#x72;&#x65;&#115;&#x73;&#69;&#109;&#97;&#x69;&#108;&#x40;&#x65;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;符号展示如下： &lt;http://www.google.com/&gt; &lt;addressEmail@email.com&gt; 8.一些字体强调 加粗 **加粗** 斜体 ***斜体*** 以上的所有标记都可以用HTML表示","categories":[{"name":"MD语法","slug":"MD语法","permalink":"http://yoursite.com/categories/MD语法/"}],"tags":[{"name":"MD语法","slug":"MD语法","permalink":"http://yoursite.com/tags/MD语法/"}]}]}